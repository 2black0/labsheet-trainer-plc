# Persiapan Simulasi Berbasis Python

Sebelum memulai implementasi sistem kendali dengan Python, diperlukan persiapan lingkungan pengembangan yang tepat dan pemahaman dasar terhadap tools yang akan digunakan. Bab ini akan memandu pembaca melalui proses instalasi, konfigurasi, dan pengenalan dasar terhadap komponen-komponen penting dalam ekosistem Python untuk sistem kendali.

Persiapan yang matang pada tahap awal akan memastikan kelancaran proses pembelajaran dan implementasi pada bab-bab selanjutnya. Pembaca akan diperkenalkan pada lingkungan pengembangan yang professional dan praktik terbaik dalam pengelolaan proyek Python untuk aplikasi engineering.

## Instalasi dan Pengelolaan Lingkungan Python

Pengelolaan lingkungan Python yang baik merupakan fondasi penting dalam pengembangan aplikasi sistem kendali. Bagian ini akan memberikan panduan komprehensif untuk menyiapkan lingkungan kerja yang robust dan terorganisir.

### Instalasi Anaconda

Anaconda adalah distribusi Python yang sangat populer untuk komputasi ilmiah dan data science. Distribusi ini mencakup Python interpreter, package manager `conda`, dan koleksi lengkap library yang umum digunakan dalam komputasi numerik.

Keunggulan menggunakan Anaconda dibandingkan instalasi Python standar antara lain:

1. Manajemen Dependensi yang Mudah: Conda menangani dependensi antar package secara otomatis
2. Lingkungan Terisolasi: Kemampuan membuat virtual environment untuk setiap proyek
3. Performa Optimal: Package sudah dikompilasi dan dioptimasi untuk performa maksimal
4. Ekosistem Lengkap: Tersedia ribuan package siap pakai melalui conda-forge

Langkah Instalasi Anaconda:

1. Unduh Installer: Kunjungi situs resmi Anaconda (https://www.anaconda.com/download) dan unduh installer sesuai sistem operasi
2. Jalankan Installer: Ikuti petunjuk instalasi dengan pengaturan default
3. Verifikasi Instalasi: Buka terminal atau command prompt dan jalankan perintah berikut:

```bash
conda --version
python --version
```

Output yang diharapkan akan menampilkan versi conda dan Python yang terinstal. Sebagai contoh:

```
conda 23.7.4
Python 3.11.5
```

4. Update Conda: Pastikan conda dalam versi terbaru dengan menjalankan:

```bash
conda update conda
```

Konfigurasi Awal Conda:

Setelah instalasi berhasil, lakukan konfigurasi awal untuk mengoptimalkan penggunaan conda:

```bash
conda config --set autoactivatebase false
conda config --add channels conda-forge
conda config --set channelpriority strict
```

Perintah pertama mencegah aktivasi otomatis environment `base`, perintah kedua menambahkan channel `conda-forge` yang memiliki koleksi package lebih lengkap, dan perintah ketiga mengatur prioritas channel untuk konsistensi instalasi.

### Pengelolaan Virtual Environment dengan Conda

Virtual environment adalah lingkungan Python terisolasi yang memungkinkan setiap proyek memiliki set package dan versi yang independen. Praktik ini mencegah konflik dependensi dan memastikan reproduktibilitas proyek.

Konsep Virtual Environment:

Setiap virtual environment berisi:

- Instalasi Python versi tertentu
- Set package yang spesifik untuk proyek
- Konfigurasi environment yang terisolasi

Membuat Virtual Environment Baru:

Untuk membuat environment khusus sistem kendali, gunakan perintah:

```bash
conda create -n control-systems python=3.11
```

Perintah ini membuat environment bernama `control-systems` dengan Python versi 3.11. Versi Python 3.11 dipilih karena kompatibilitasnya yang baik dengan library sistem kendali dan performanya yang optimal.

Aktivasi dan Deaktivasi Environment:

```bash
# Aktivasi environment
conda activate control-systems

# Deaktivasi environment
conda deactivate
```

Ketika environment aktif, prompt terminal akan menampilkan nama environment dalam tanda kurung, misalnya `(control-systems)`.

Mengelola Environment:

```bash
# Melihat daftar environment
conda env list

# Menghapus environment
conda env remove -n control-systems

# Export environment ke file
conda env export -n control-systems > environment.yml

# Membuat environment dari file
conda env create -f environment.yml
```

Best practices dalam pengelolaan environment:

1. Gunakan Nama Deskriptif: Berikan nama yang jelas menggambarkan tujuan proyek
2. Dokumentasi Dependensi: Selalu export environment untuk reproduktibilitas
3. Pemisahan Proyek: Setiap proyek sebaiknya memiliki environment terpisah
4. Update Berkala: Lakukan update package secara berkala untuk keamanan

[@tbl:conda-commands] merangkum perintah-perintah penting dalam pengelolaan environment conda.

| Perintah           | Fungsi                         | Contoh                              |
|--------------------|--------------------------------|-------------------------------------|
| `conda create`     | Membuat environment baru       | `conda create -n myenv python=3.11` |
| `conda activate`   | Mengaktifkan environment       | `conda activate myenv`              |
| `conda deactivate` | Menonaktifkan environment      | `conda deactivate`                  |
| `conda env list`   | Melihat daftar environment     | `conda env list`                    |
| `conda env export` | Export konfigurasi environment | `conda env export > env.yml`        |
| `conda env create` | Membuat environment dari file  | `conda env create -f env.yml`       |

: Perintah Penting Conda untuk Pengelolaan Environment {#tbl:conda-commands}

## Instalasi dan Penggunaan Library Utama

Ekosistem Python untuk sistem kendali didukung oleh berbagai library yang masing-masing memiliki peran spesifik. Bagian ini akan memandu instalasi dan memberikan gambaran fungsi dari setiap library utama.

### Instalasi Library

Setelah mengaktifkan environment yang telah dibuat, langkah selanjutnya adalah menginstal library yang diperlukan. Instalasi akan dilakukan secara bertahap untuk memastikan kompatibilitas dan menghindari konflik dependensi.

Instalasi Library Dasar:

```bash
conda activate control-systems
conda install numpy scipy matplotlib jupyter notebook
```

Instalasi Library Sistem Kendali:

```bash
conda install -c conda-forge control
pip install slycot
```

Library `control` (python-control) tidak tersedia di channel utama conda, sehingga diinstal dari `conda-forge`. Library `slycot` diinstal menggunakan `pip` karena menyediakan algoritma numerik yang dioptimasi untuk sistem kendali.

Instalasi Library Tambahan:

```bash
conda install sympy pandas seaborn ipywidgets
```

Verifikasi Instalasi:

Untuk memverifikasi bahwa semua library terinstal dengan benar, buat script Python sederhana:

```python
import numpy as np
import scipy
import matplotlib.pyplot as plt
import control
import sympy as sp
import jupyter

print("NumPy version:", np.version)
print("SciPy version:", scipy.version)
print("Matplotlib version:", plt.matplotlib.version)
print("Control library version:", control.version)
print("SymPy version:", sp.version)

print("\nSemua library berhasil diimport!")
```

Jika tidak ada pesan error, maka instalasi telah berhasil.

Troubleshooting Instalasi:

Masalah umum yang mungkin terjadi dan solusinya:

1. Konflik Dependensi: Gunakan `conda search` untuk memeriksa versi yang kompatibel
2. Package Tidak Ditemukan: Pastikan channel yang tepat sudah ditambahkan
3. Error Kompilasi: Instal build tools yang diperlukan untuk sistem operasi
4. Masalah Permission: Gunakan virtual environment untuk menghindari masalah permission

[@tbl:library-installation] merangkum metode instalasi yang direkomendasikan untuk setiap library.

| Library        | Metode Instalasi | Channel/Sumber | Keterangan                    |
|----------------|------------------|----------------|-------------------------------|
| NumPy          | `conda install`  | default        | Library numerik dasar         |
| SciPy          | `conda install`  | default        | Algoritma ilmiah lanjutan     |
| Matplotlib     | `conda install`  | default        | Visualisasi dan plotting      |
| Jupyter        | `conda install`  | default        | Environment interaktif        |
| python-control | `conda install`  | conda-forge    | Library khusus sistem kendali |
| Slycot         | `pip install`    | PyPI           | Algoritma numerik optimal     |
| SymPy          | `conda install`  | default        | Komputasi simbolik            |

: Metode Instalasi Library Python untuk Sistem Kendali {#tbl:library-installation}

## Pengantar Penggunaan Jupyter Notebook

Jupyter Notebook adalah environment pemrograman interaktif yang sangat cocok untuk eksplorasi data, prototyping, dan dokumentasi. Dalam konteks sistem kendali, Jupyter memungkinkan kombinasi antara kode, visualisasi, dan penjelasan dalam satu dokumen.

### Menjalankan Jupyter Notebook

Untuk memulai Jupyter Notebook, jalankan perintah berikut dalam environment yang telah diaktifkan:

```bash
jupyter notebook
```

Perintah ini akan membuka browser dengan antarmuka Jupyter yang menampilkan direktori kerja saat ini.

### Fitur-Fitur Penting Jupyter

Sel Kode dan Markdown:

Jupyter menggunakan konsep sel (cell) yang dapat berisi kode Python atau teks Markdown. Kombinasi ini memungkinkan pembuatan dokumentasi yang kaya dengan contoh kode yang dapat dijalankan.

Magic Commands:

Jupyter menyediakan magic commands yang berguna untuk berbagai keperluan:

```python
# Mengukur waktu eksekusi
%time result = somefunction()

# Menampilkan plot inline
%matplotlib inline

# Memuat file eksternal
%load externalscript.py

# Informasi sistem
%system
```

Widgets Interaktif:

Untuk aplikasi sistem kendali, widgets interaktif sangat berguna untuk eksplorasi parameter:

```python
from ipywidgets import interact, FloatSlider
import matplotlib.pyplot as plt
import numpy as np

def plotstepresponse(K, tau):
    t = np.linspace(0, 5*tau, 1000)
    y = K * (1 - np.exp(-t/tau))

    plt.figure(figsize=(8, 5))
    plt.plot(t, y)
    plt.title(f'Step Response (K={K}, tau={tau})')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.grid(True)
    plt.show()

interact(plotstepresponse,
         K=FloatSlider(min=0.1, max=5.0, step=0.1, value=1.0),
         tau=FloatSlider(min=0.1, max=2.0, step=0.1, value=1.0))
```

Kode di atas membuat widget interaktif yang memungkinkan pengguna mengubah parameter K dan tau untuk melihat pengaruhnya terhadap respons sistem secara real-time.

### Best Practices untuk Jupyter

1. Organisasi Sel: Pisahkan import, definisi fungsi, dan analisis dalam sel yang berbeda
2. Dokumentasi: Gunakan sel Markdown untuk menjelaskan tujuan dan hasil analisis
3. Restart Kernel: Secara berkala restart kernel untuk memastikan konsistensi state
4. Version Control: Gunakan tools seperti `nbstripout` untuk menghapus output sebelum commit

## Pengantar Penggunaan NumPy

NumPy (Numerical Python) adalah library fundamental untuk komputasi numerik di Python. Dalam sistem kendali, NumPy berperan penting dalam operasi matriks, komputasi numerik, dan manipulasi data.

### Struktur Data Dasar: Array

Array NumPy adalah struktur data homogen multidimensional yang efisien untuk operasi numerik:

```python
import numpy as np

# Membuat array 1D
time = np.linspace(0, 10, 100)  # 100 titik dari 0 sampai 10

# Membuat array 2D (matriks)
A = np.array([[1, 2], [3, 4]])
B = np.array([[5], [6]])

# Array dengan nilai tertentu
zerosmatrix = np.zeros((3, 3))
identitymatrix = np.eye(4)
randommatrix = np.random.rand(2, 3)
```

Array NumPy memiliki keunggulan dibandingkan list Python dalam hal performa dan fungionalitas khusus numerik.

### Operasi Matriks untuk Sistem Kendali

Dalam sistem kendali, operasi matriks sangat penting untuk analisis state-space dan komputasi numerik:

```python
# State-space matrices
A = np.array([[-1, 1], [0, -2]])
B = np.array([[0], [1]])
C = np.array([[1, 0]])
D = np.array([[0]])

# Eigenvalues (poles sistem)
eigenvalues = np.linalg.eig(A)[0]
print(f"Poles sistem: {eigenvalues}")

# Matrix exponential untuk solusi state-space
from scipy.linalg import expm
t = 1.0
expAt = expm(A * t)

# Controllability matrix
n = A.shape[0]
Wc = B
for i in range(1, n):
    Wc = np.hstack([Wc, np.linalg.matrixpower(A, i) @ B])
rankWc = np.linalg.matrixrank(Wc)
```

Contoh di atas menunjukkan operasi-operasi matriks yang umum dalam analisis sistem kendali, termasuk perhitungan eigenvalue, matrix exponential, dan controllability matrix.

### Operasi Numerik untuk Simulasi

NumPy menyediakan fungsi-fungsi numerik yang diperlukan untuk simulasi sistem:

```python
# Sinyal input
t = np.linspace(0, 5, 1000)
stepinput = np.oneslike(t)
rampinput = t
sinusoidalinput = np.sin(2 * np.pi * t)

# Noise dan disturbance
noise = np.random.normal(0, 0.1, len(t))
disturbance = 0.5 * np.sin(10 * t)

# Operasi statistik untuk analisis
meanerror = np.mean(noise)
stderror = np.std(noise)
rmserror = np.sqrt(np.mean(noise2))
```

[@tbl:numpy-functions] merangkum fungsi-fungsi NumPy yang penting untuk sistem kendali.

| Kategori          | Fungsi                               | Kegunaan                  |
|-------------------|--------------------------------------|---------------------------|
| Pembuatan Array   | `np.linspace()`, `np.arange()`       | Membuat vektor waktu      |
| Operasi Matriks   | `np.dot()`, `np.linalg.eig()`        | Operasi aljabar linear    |
| Fungsi Matematika | `np.sin()`, `np.exp()`               | Sinyal dan respons sistem |
| Statistik         | `np.mean()`, `np.std()`              | Analisis performa         |
| Aljabar Linear    | `np.linalg.inv()`, `np.linalg.det()` | Analisis sistem           |

: Fungsi-Fungsi Penting NumPy untuk Sistem Kendali {#tbl:numpy-functions}

## Pengantar Penggunaan Matplotlib

Matplotlib adalah library visualisasi yang sangat penting dalam analisis sistem kendali. Kemampuannya untuk membuat berbagai jenis plot memungkinkan visualisasi respons sistem, diagram frekuensi, dan analisis performa.

### Plot Dasar untuk Sistem Kendali

Plot Respons Waktu:

```python
import matplotlib.pyplot as plt
import numpy as np

# Parameter sistem orde-2
wn = 2.0  # natural frequency
zeta = 0.5  # damping ratio

# Waktu simulasi
t = np.linspace(0, 5, 1000)

# Respons step sistem orde-2
wd = wn * np.sqrt(1 - zeta2)
y = 1 - np.exp(-zeta*wn*t) * (np.cos(wd*t) + (zeta*wn/wd)*np.sin(wd*t))

# Plot dengan formatting yang baik
plt.figure(figsize=(10, 6))
plt.plot(t, y, 'b-', linewidth=2, label='System Response')
plt.axhline(y=1, color='r', linestyle='--', alpha=0.7, label='Steady State')
plt.axhline(y=1.1, color='g', linestyle=':', alpha=0.7, label='+10% Line')

plt.xlabel('Time [s]')
plt.ylabel('Output')
plt.title(f'Step Response (ζ={zeta}, ωn={wn} rad/s)')
plt.legend()
plt.grid(True, alpha=0.3)
plt.xlim(0, 5)
plt.ylim(0, 1.4)
plt.show()
```

Subplot untuk Perbandingan:

```python
# Perbandingan berbagai nilai damping
fig, axes = plt.subplots(2, 2, figsize=(12, 8))
zetavalues = [0.1, 0.5, 0.7, 1.0]
titles = ['Underdamped (ζ=0.1)', 'Underdamped (ζ=0.5)',
          'Underdamped (ζ=0.7)', 'Critically Damped (ζ=1.0)']

for i, (ax, zeta, title) in enumerate(zip(axes.flat, zetavalues, titles)):
    if zeta < 1:
        wd = wn * np.sqrt(1 - zeta2)
        y = 1 - np.exp(-zeta*wn*t) * (np.cos(wd*t) + (zeta*wn/wd)*np.sin(wd*t))
    else:
        y = 1 - np.exp(-wn*t) * (1 + wn*t)

    ax.plot(t, y, 'b-', linewidth=2)
    ax.settitle(title)
    ax.grid(True, alpha=0.3)
    ax.setylim(0, 1.4)

plt.tightlayout()
plt.show()
```

### Kustomisasi dan Styling

Matplotlib memungkinkan kustomisasi yang ekstensif untuk menghasilkan plot berkualitas publikasi:

```python
# Mengatur style
plt.style.use('seaborn-v08')
plt.rcParams['figure.figsize'] = (10, 6)
plt.rcParams['font.size'] = 12
plt.rcParams['lines.linewidth'] = 2

# Custom colormap untuk multiple plots
colors = plt.cm.viridis(np.linspace(0, 1, 4))

# Plot dengan styling custom
fig, ax = plt.subplots()
for i, zeta in enumerate([0.1, 0.3, 0.5, 0.7]):
    wd = wn * np.sqrt(1 - zeta2)
    y = 1 - np.exp(-zeta*wn*t) * (np.cos(wd*t) + (zeta*wn/wd)*np.sin(wd*t))
    ax.plot(t, y, color=colors[i], label=f'ζ = {zeta}')

ax.setxlabel('Time [s]')
ax.setylabel('Amplitude')
ax.settitle('Effect of Damping Ratio on Step Response')
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()
```

### Animasi untuk Visualisasi Dinamis

Untuk sistem kendali, animasi dapat membantu memahami perilaku dinamis:

```python
from matplotlib.animation import FuncAnimation

# Setup figure dan axis
fig, ax = plt.subplots()
x = np.linspace(0, 2*np.pi, 100)
line, = ax.plot(x, np.sin(x))

def animate(frame):
    line.setydata(np.sin(x + frame/10))
    return line,

anim = FuncAnimation(fig, animate, frames=200, interval=50, blit=True)
plt.show()
```

## Pengantar Penggunaan python-control

python-control adalah library khusus yang dirancang untuk analisis dan desain sistem kendali. Library ini menyediakan fungsi-fungsi yang setara dengan MATLAB Control Systems Toolbox.

### Pembuatan Model Sistem

Transfer Function:

```python
import control as ct
import numpy as np
import matplotlib.pyplot as plt

# Membuat transfer function
# H(s) = 10 / (s^2 + 2s + 10)
num = [10]
den = [1, 2, 10]
H = ct.tf(num, den)

print("Transfer Function:")
print(H)
```

State-Space Model:

```python
# State-space representation
# dx/dt = Ax + Bu
# y = Cx + Du
A = np.array([[-2, -10], [1, 0]])
B = np.array([[1], [0]])
C = np.array([[0, 10]])
D = np.array([[0]])

sysss = ct.ss(A, B, C, D)
print("State-Space Model:")
print(sysss)

# Konversi antara representasi
Hfromss = ct.tf(sysss)
sysssfromtf = ct.ss(H)
```

### Analisis Sistem

Respons Waktu:

```python
# Step response
tstep, ystep = ct.stepresponse(H)

# Impulse response
timpulse, yimpulse = ct.impulseresponse(H)

# Custom input response
t = np.linspace(0, 5, 1000)
u = np.sin(t)  # sinusoidal input
tout, yout = ct.forcedresponse(H, t, u)

# Plot results
fig, axes = plt.subplots(1, 3, figsize=(15, 4))

axes[0].plot(tstep, ystep)
axes[0].settitle('Step Response')
axes[0].grid(True)

axes[1].plot(timpulse, yimpulse)
axes[1].settitle('Impulse Response')
axes[1].grid(True)

axes[2].plot(tout, yout)
axes[2].settitle('Response to Sinusoidal Input')
axes[2].grid(True)

plt.tightlayout()
plt.show()
```

Analisis Stabilitas:

```python
# Poles dan zeros
poles = ct.pole(H)
zeros = ct.zero(H)

print(f"Poles: {poles}")
print(f"Zeros: {zeros}")

# Margin stabilitas
gm, pm, wg, wp = ct.margin(H)
print(f"Gain Margin: {gm:.2f} dB")
print(f"Phase Margin: {pm:.2f} degrees")
```

Plot Frekuensi:

```python
# Bode plot
ct.bodeplot(H)
plt.show()

# Nyquist plot
ct.nyquistplot(H)
plt.show()

# Root locus
ct.rlocusplot(H)
plt.show()
```

### Desain Kontroler

PID Controller:

```python
# Plant transfer function
plant = ct.tf([1], [1, 1, 0])  # Double integrator

# PID controller design
Kp, Ki, Kd = 10, 5, 2
pid = ct.tf([Kd, Kp, Ki], [1, 0])

# Closed-loop system
closedloop = ct.feedback(pid * plant, 1)

# Analisis closed-loop
t, y = ct.stepresponse(closedloop)
plt.figure(figsize=(10, 6))
plt.plot(t, y)
plt.title('Closed-Loop Step Response')
plt.xlabel('Time [s]')
plt.ylabel('Output')
plt.grid(True)
plt.show()

# Performance metrics
info = ct.stepinfo(closedloop)
print("Performance Metrics:")
for key, value in info.items():
    print(f"{key}: {value:.3f}")
```

[@tbl:control-functions] merangkum fungsi-fungsi penting dalam python-control.

| Kategori           | Fungsi                                      | Kegunaan               |
|--------------------|---------------------------------------------|------------------------|
| Model Creation     | `ct.tf()`, `ct.ss()`                        | Membuat model sistem   |
| Time Response      | `ct.stepresponse()`, `ct.impulseresponse()` | Analisis respons waktu |
| Frequency Response | `ct.bodeplot()`, `ct.nyquistplot()`         | Analisis frekuensi     |
| Stability          | `ct.pole()`, `ct.margin()`                  | Analisis stabilitas    |
| Controller Design  | `ct.feedback()`, `ct.rlocus()`              | Desain sistem kendali  |

: Fungsi-Fungsi Penting python-control {#tbl:control-functions}

### Integrasi dengan NumPy dan Matplotlib

Salah satu keunggulan python-control adalah integrasinya yang mulus dengan ekosistem Python:

```python
# Menggunakan NumPy arrays untuk parameter
frequencies = np.logspace(-2, 2, 1000)
mag, phase, omega = ct.frequencyresponse(H, frequencies)

# Custom plotting dengan Matplotlib
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))

ax1.semilogx(omega, 20*np.log10(np.abs(mag)))
ax1.setylabel('Magnitude [dB]')
ax1.grid(True)

ax2.semilogx(omega, np.angle(mag)*180/np.pi)
ax2.setxlabel('Frequency [rad/s]')
ax2.setylabel('Phase [degrees]')
ax2.grid(True)

plt.tightlayout()
plt.show()
```

## Validasi Setup dan Troubleshooting

Untuk memastikan bahwa semua komponen telah terinstal dan berfungsi dengan benar, jalankan script validasi komprehensif berikut:

```python
import sys
import numpy as np
import scipy
import matplotlib.pyplot as plt
import control
import sympy as sp
from IPython.display import display, HTML

def validationtest():
    """Comprehensive validation of control systems environment."""

    print("="*60)
    print("VALIDASI LINGKUNGAN SISTEM KENDALI PYTHON")
    print("="*60)

    # Test 1: Basic imports
    print("\n1. Testing basic imports...")
    try:
        import numpy as np
        import scipy
        import matplotlib.pyplot as plt
        import control
        import sympy as sp
        print("   [OK] All basic libraries imported successfully")
    except ImportError as e:
        print(f"   [ERROR] Import error: {e}")
        return False

    # Test 2: NumPy operations
    print("\n2. Testing NumPy operations...")
    try:
        A = np.array([[1, 2], [3, 4]])
        eigenvals = np.linalg.eig(A)[0]
        print(f"   [OK] Matrix eigenvalues: {eigenvals}")
    except Exception as e:
        print(f"   [ERROR] NumPy error: {e}")
        return False

    # Test 3: Control library functionality
    print("\n3. Testing control library...")
    try:
        H = control.tf([1], [1, 2, 1])
        poles = control.pole(H)
        print(f"   [OK] Transfer function poles: {poles}")
    except Exception as e:
        print(f"   [ERROR] Control library error: {e}")
        return False

    # Test 4: Plotting capability
    print("\n4. Testing plotting...")
    try:
        t = np.linspace(0, 5, 100)
        y = np.exp(-t)
        plt.figure(figsize=(6, 4))
        plt.plot(t, y)
        plt.title('Test Plot')
        plt.close()  # Close to avoid display in script
        print("   [OK] Matplotlib plotting works")
    except Exception as e:
        print(f"   [ERROR] Plotting error: {e}")
        return False

    # Test 5: Integration test
    print("\n5. Testing integration...")
    try:
        systf = control.tf([2], [1, 3, 2])
        t, y = control.stepresponse(systf)
        print(f"   [OK] Step response calculated ({len(t)} points)")
    except Exception as e:
        print(f"   [ERROR] Integration error: {e}")
        return False

    print("\n" + "="*60)
    print("SEMUA TEST BERHASIL! Environment siap digunakan.")
    print("="*60)
    return True

# Jalankan validasi
validationtest()
```

Common Issues dan Solutions:

1. Import Error pada control library:

   - Solusi: `conda install -c conda-forge control`

2. Missing slycot:

   - Solusi: `pip install slycot`

3. Matplotlib backend issues:

   - Solusi: Set backend explicitly dengan `plt.switchbackend('TkAgg')`

4. Jupyter widgets tidak muncul:
   - Solusi: `jupyter nbextension enable --py widgetsnbextension`

Dengan menyelesaikan instalasi dan validasi pada bab ini, pembaca telah mempersiapkan fondasi yang solid untuk mempelajari implementasi sistem kendali dengan Python pada bab-bab selanjutnya. Lingkungan yang telah disiapkan akan mendukung semua aktivitas pembelajaran dari pemodelan dasar hingga simulasi robotika yang lebih kompleks.

