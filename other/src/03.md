# Pemodelan Sistem

Pemodelan sistem merupakan langkah fundamental dalam analisis dan desain sistem kendali. Proses ini melibatkan transformasi sistem fisik yang kompleks menjadi representasi matematis yang dapat dianalisis, disimulasikan, dan digunakan untuk desain kontroler. Bab ini akan membahas konsep dasar pemodelan, berbagai teknik representasi model, dan implementasinya menggunakan Python.

Pemahaman yang mendalam tentang pemodelan sistem akan memungkinkan insinyur untuk menganalisis perilaku sistem, memprediksi respons, dan merancang kontroler yang efektif. Setiap sistem fisik memiliki karakteristik unik yang memerlukan pendekatan pemodelan yang tepat untuk menghasilkan model yang akurat namun cukup sederhana untuk dianalisis.

## Konsep Dasar dan Langkah Pemodelan Sistem

Pemodelan sistem adalah proses abstraksi dimana sistem fisik yang kompleks disederhanakan menjadi representasi matematis yang dapat dimanipulasi dan dianalisis. Tujuan utama pemodelan adalah untuk memperoleh pemahaman yang mendalam tentang perilaku sistem dan menggunakan pemahaman tersebut untuk desain dan analisis.

### Filosofi Pemodelan

Dalam pemodelan sistem, terdapat trade-off mendasar antara akurasi dan kesederhanaan. Model yang sangat akurat mungkin terlalu kompleks untuk analisis, sementara model yang terlalu sederhana mungkin tidak menangkap karakteristik penting sistem. Prinsip parsimony menyatakan bahwa model terbaik adalah yang paling sederhana namun masih dapat menjelaskan fenomena yang diamati dengan akurasi yang memadai.

George Box pernah menyatakan bahwa "semua model salah, tetapi beberapa model berguna". Pernyataan ini menekankan bahwa tujuan pemodelan bukan untuk menciptakan representasi sempurna dari realitas, melainkan untuk menghasilkan alat yang berguna untuk analisis dan desain.

### Langkah-Langkah Pemodelan Sistem

Proses pemodelan sistem dapat dibagi menjadi beberapa tahap sistematis:

#### 1. Identifikasi dan Definisi Sistem

Tahap awal melibatkan identifikasi batasan sistem, variabel input dan output, serta asumsi-asumsi yang akan digunakan. Pada tahap ini, insinyur harus menentukan:

- Tujuan pemodelan (analisis stabilitas, desain kontroler, simulasi, dll.)
- Tingkat detail yang diperlukan
- Rentang operasi yang akan dimodelkan
- Fenomena fisik yang dapat diabaikan

#### 2. Formulasi Hukum Fisik

Berdasarkan prinsip-prinsip fisika dasar, formulasikan persamaan yang menggambarkan perilaku sistem. Hukum-hukum yang umum digunakan meliputi:

- Hukum Newton untuk sistem mekanik
- Hukum Kirchhoff untuk sistem elektrik
- Hukum kekekalan massa dan energi untuk sistem proses
- Hukum termodinamika untuk sistem termal

#### 3. Linearisasi

Kebanyakan sistem fisik bersifat nonlinear, namun untuk analisis sistem kendali klasik, diperlukan model linear. Linearisasi dapat dilakukan melalui:

- Linearisasi di sekitar titik operasi (operating point)
- Aproksimasi sinyal kecil (small signal approximation)
- Penggunaan metode perturbasi

#### 4. Transformasi ke Domain Laplace

Untuk memudahkan analisis, persamaan diferensial ditransformasi ke domain Laplace, menghasilkan fungsi alih (transfer function) atau representasi state-space.

[@tbl:tahap-pemodelan] merangkum tahap-tahap pemodelan sistem dengan output yang dihasilkan pada setiap tahap.

| Tahap        | Aktivitas Utama                   | Output                          |
| ------------ | --------------------------------- | ------------------------------- |
| Identifikasi | Definisi batasan sistem, I/O      | Spesifikasi sistem              |
| Formulasi    | Penerapan hukum fisika            | Persamaan diferensial           |
| Linearisasi  | Aproksimasi di titik operasi      | Persamaan linear                |
| Transformasi | Laplace transform                 | Transfer function / State-space |
| Validasi     | Verifikasi dengan data eksperimen | Model tervalidasi               |

: Tahap-Tahap Pemodelan Sistem {#tbl:tahap-pemodelan}

### Klasifikasi Model Sistem

Model sistem dapat diklasifikasikan berdasarkan berbagai kriteria:

Berdasarkan Sifat Matematis:

- Linear vs Nonlinear: Model linear memenuhi prinsip superposisi
- Time-invariant vs Time-variant: Parameter konstan atau berubah terhadap waktu
- Lumped vs Distributed: Parameter terkonsentrasi atau terdistribusi

Berdasarkan Sifat Stokastik:

- Deterministik: Output ditentukan secara unik oleh input
- Stokastik: Mengandung elemen acak atau noise

Berdasarkan Kompleksitas:

- SISO (Single Input Single Output)
- MIMO (Multiple Input Multiple Output)

## Representasi Model Sistem

Dalam sistem kendali linear, terdapat dua representasi utama yang ekivalen namun memiliki karakteristik dan kegunaan yang berbeda: fungsi alih (transfer function) dan model ruang keadaan (state-space).

### Fungsi Alih (Transfer Function)

Fungsi alih adalah representasi matematis hubungan antara input dan output sistem dalam domain Laplace, dengan asumsi kondisi awal nol. Untuk sistem SISO, fungsi alih didefinisikan sebagai:

$$
H(s) = \frac{Y(s)}{U(s)} = \frac{bm s^m + b{m-1} s^{m-1} + \cdots + b1 s + b0}{an s^n + a{n-1} s^{n-1} + \cdots + a1 s + a0}
$$

dimana $Y(s)$ adalah transformasi Laplace dari output $y(t)$, $U(s)$ adalah transformasi Laplace dari input $u(t)$, dan $n \geq m$ untuk sistem yang realisabel secara fisik.

Implementasi Fungsi Alih di Python:

```python
import numpy as np
import control as ct
import matplotlib.pyplot as plt

num = [2, 5]
den = [1, 4, 5]
H = ct.tf(num, den)

print("Transfer Function:")
print(H)

poles = ct.pole(H)
zeros = ct.zero(H)
print(f"Poles: {poles}")
print(f"Zeros: {zeros}")
```

Kode di atas membuat fungsi alih $H(s) = \frac{2s + 5}{s^2 + 4s + 5}$ dan menampilkan poles serta zeros sistem. Poles menentukan karakteristik respons natural sistem, sedangkan zeros mempengaruhi bentuk respons terhadap input.

Karakteristik Fungsi Alih:

1. Orde Sistem: Ditentukan oleh pangkat tertinggi penyebut (denominator)
2. Poles dan Zeros: Nilai $s$ yang membuat penyebut dan pembilang menjadi nol
3. Gain Steady-State: Nilai $H(0)$ untuk input step
4. Tipe Sistem: Ditentukan oleh jumlah poles di origin ($s = 0$)

Keunggulan Fungsi Alih:

- Representasi compact untuk sistem SISO
- Mudah untuk analisis frekuensi
- Intuisi langsung tentang poles dan zeros
- Kompatibel dengan teknik analisis klasik

Keterbatasan Fungsi Alih:

- Terbatas pada sistem SISO
- Tidak memberikan informasi tentang internal states
- Sulit untuk sistem MIMO
- Asumsi kondisi awal nol

### Model Ruang Keadaan (State-Space)

Model state-space adalah representasi yang lebih umum dan powerful, terutama untuk sistem MIMO dan analisis modern. Model ini menggunakan variabel keadaan (state variables) untuk menggambarkan kondisi internal sistem.

Representasi Matematis:

$$
\dot{\mathbf{x}}(t) = \mathbf{A}\mathbf{x}(t) + \mathbf{B}\mathbf{u}(t)
$$

$$
\mathbf{y}(t) = \mathbf{C}\mathbf{x}(t) + \mathbf{D}\mathbf{u}(t)
$$

dimana:

- $\mathbf{x}(t) \in \mathbb{R}^n$ adalah vektor state
- $\mathbf{u}(t) \in \mathbb{R}^m$ adalah vektor input
- $\mathbf{y}(t) \in \mathbb{R}^p$ adalah vektor output
- $\mathbf{A} \in \mathbb{R}^{n \times n}$ adalah matriks sistem
- $\mathbf{B} \in \mathbb{R}^{n \times m}$ adalah matriks input
- $\mathbf{C} \in \mathbb{R}^{p \times n}$ adalah matriks output
- $\mathbf{D} \in \mathbb{R}^{p \times m}$ adalah matriks feedthrough

Implementasi State-Space di Python:

```python
import numpy as np
import control as ct

A = np.array([[-2, -3], [1, 0]])
B = np.array([[1], [0]])
C = np.array([[0, 2]])
D = np.array([[0]])

sysss = ct.ss(A, B, C, D)
print("State-Space Model:")
print(sysss)

Hfromss = ct.tf(sysss)
print("\nEquivalent Transfer Function:")
print(Hfromss)

eigenvalues = np.linalg.eig(A)[0]
print(f"\nEigenvalues (Poles): {eigenvalues}")
```

Kode ini membuat model state-space dan menunjukkan konversi ke fungsi alih yang ekivalen. Eigenvalues dari matriks $\mathbf{A}$ adalah poles sistem, yang menentukan stabilitas dan karakteristik respons.

Keunggulan State-Space:

- Dapat menangani sistem MIMO
- Memberikan informasi tentang kondisi internal
- Cocok untuk analisis modern dan optimal control
- Mudah untuk simulasi numerik
- Dapat menangani kondisi awal yang tidak nol

Keterbatasan State-Space:

- Lebih kompleks untuk sistem SISO sederhana
- Representasi tidak unik (terdapat banyak realisasi)
- Memerlukan pemahaman konsep aljabar linear

### Konversi Antara Representasi

Python menyediakan fungsi untuk konversi antara berbagai representasi:

```python
num = [1, 2]
den = [1, 3, 2]
H = ct.tf(num, den)

sysss = ct.ss(H)
print("Conversion TF to SS:")
print(sysss)

Hback = ct.tf(sysss)
print("\nConversion SS back to TF:")
print(Hback)

A, B, C, D = ct.ssdata(sysss)
print(f"\nMatrices:")
print(f"A = \n{A}")
print(f"B = \n{B}")
print(f"C = \n{C}")
print(f"D = \n{D}")
```

Konversi ini memungkinkan penggunaan representasi yang paling sesuai untuk setiap jenis analisis.

## Diagram Blok Sistem Kendali

Diagram blok adalah representasi grafis yang menunjukkan hubungan fungsional antar komponen sistem. Setiap blok merepresentasikan operasi matematis, biasanya fungsi alih, dan panah menunjukkan arah aliran sinyal.

### Elemen Dasar Diagram Blok

Komponen Fundamental:

1. Blok: Merepresentasikan operasi matematis (biasanya fungsi alih)
2. Summing Junction: Titik penjumlahan atau pengurangan sinyal
3. Takeoff Point: Titik percabangan sinyal
4. Signal Flow: Arah aliran sinyal

```python
import control as ct
import matplotlib.pyplot as plt

G1 = ct.tf([1], [1, 1])
G2 = ct.tf([2], [1, 2])
H = ct.tf([1], [1, 0.5])

print("Individual Transfer Functions:")
print(f"G1(s) = {G1}")
print(f"G2(s) = {G2}")
print(f"H(s) = {H}")
```

### Hubungan Seri

Dalam konfigurasi seri, output dari satu blok menjadi input untuk blok berikutnya. Fungsi alih total adalah perkalian dari semua fungsi alih individual:

$$
G{total}(s) = G1(s) \cdot G2(s) \cdot \ldots \cdot Gn(s)
$$

```python
Gseries = ct.series(G1, G2)
print(f"Series Connection: G1 * G2 = {Gseries}")
```

Hubungan seri menghasilkan sistem dengan orde yang merupakan jumlah orde individual. Bandwidth sistem keseluruhan ditentukan oleh komponen dengan bandwidth terendah.

### Hubungan Paralel

Dalam konfigurasi paralel, input yang sama diberikan ke semua blok, dan output total adalah jumlah dari semua output individual:

$$
G{total}(s) = G1(s) + G2(s) + \ldots + Gn(s)
$$

```python
Gparallel = ct.parallel(G1, G2)
print(f"Parallel Connection: G1 + G2 = {Gparallel}")
```

Konfigurasi paralel dapat digunakan untuk meningkatkan bandwidth, redundancy, atau mengkombinasikan berbagai karakteristik respons.

### Hubungan Umpan Balik (Feedback)

Sistem umpan balik adalah konfigurasi dimana output dikembalikan ke input melalui jalur umpan balik. Untuk umpan balik negatif:

$$
G{closed}(s) = \frac{G(s)}{1 + G(s)H(s)}
$$

dimana $G(s)$ adalah fungsi alih forward path dan $H(s)$ adalah fungsi alih feedback path.

```python
Gforward = ct.series(G1, G2)
Gclosed = ct.feedback(Gforward, H)
print(f"Closed-Loop Transfer Function: {Gclosed}")
```

Umpan balik negatif umumnya meningkatkan stabilitas, mengurangi sensitivitas terhadap gangguan, dan memperbaiki akurasi steady-state.

### Reduksi Diagram Blok

Sistem yang kompleks dapat disederhanakan menggunakan aturan aljabar diagram blok:

```python
def blockreductionexample():
    G1 = ct.tf([1], [1, 1])
    G2 = ct.tf([2], [1, 2])
    G3 = ct.tf([0.5], [1, 0.5])
    H1 = ct.tf([1], [1])
    H2 = ct.tf([0.1], [1])

    print("Original system components:")
    print(f"G1 = {G1}")
    print(f"G2 = {G2}")
    print(f"G3 = {G3}")

    innerloop = ct.feedback(G2, H2)
    print(f"\nInner loop: G2/(1+G2*H2) = {innerloop}")

    forwardpath = ct.series(G1, innerloop, G3)
    print(f"Forward path: G1*innerloop*G3 = {forwardpath}")

    overallsystem = ct.feedback(forwardpath, H1)
    print(f"Overall system: {overallsystem}")

    return overallsystem

overalltf = blockreductionexample()
```

[@tbl:block-algebra] merangkum aturan-aturan dasar aljabar diagram blok.

| Konfigurasi         | Rumus                       | Keterangan                      |
| ------------------- | --------------------------- | ------------------------------- |
| Seri                | $G1(s) \cdot G2(s)$         | Output G1 → Input G2            |
| Paralel             | $G1(s) + G2(s)$             | Input sama, output dijumlah     |
| Umpan Balik Negatif | $\frac{G(s)}{1 + G(s)H(s)}$ | Loop negatif standar            |
| Umpan Balik Positif | $\frac{G(s)}{1 - G(s)H(s)}$ | Loop positif (jarang digunakan) |

: Aturan Aljabar Diagram Blok {#tbl:block-algebra}

## Contoh Pemodelan Sistem Fisik

Bagian ini akan membahas pemodelan sistem fisik nyata yang sering dijumpai dalam aplikasi engineering. Setiap contoh akan menunjukkan proses lengkap dari formulasi fisik hingga implementasi dalam Python.

### Sistem Mekanik (Massa-Pegas-Redam)

Sistem massa-pegas-redam adalah sistem mekanik fundamental yang banyak dijumpai dalam aplikasi engineering. Sistem ini terdiri dari massa $m$, konstanta pegas $k$, dan koefisien redaman $c$.

Analisis Fisik:

Berdasarkan hukum Newton kedua, persamaan gerak sistem adalah:

$$
m\ddot{x} + c\dot{x} + kx = F(t)
$$

dimana $x(t)$ adalah posisi massa dan $F(t)$ adalah gaya eksternal yang diberikan.

Transformasi Laplace:

Dengan asumsi kondisi awal nol, transformasi Laplace memberikan:

$$
ms^2X(s) + csX(s) + kX(s) = F(s)
$$

Fungsi alih dari gaya ke posisi adalah:

$$
H(s) = \frac{X(s)}{F(s)} = \frac{1}{ms^2 + cs + k}
$$

Implementasi Python:

```python
import numpy as np
import control as ct
import matplotlib.pyplot as plt

def massspringdamper(m, c, k):
    num = [1]
    den = [m, c, k]
    return ct.tf(num, den)

m = 1.0
c = 2.0
k = 5.0

Hmsd = massspringdamper(m, c, k)
print(f"Mass-Spring-Damper TF: {Hmsd}")

wn = np.sqrt(k/m)
zeta = c / (2 * np.sqrt(k*m))
print(f"Natural frequency (ωn): {wn:.2f} rad/s")
print(f"Damping ratio (ζ): {zeta:.2f}")
```

Sistem ini menunjukkan karakteristik orde dua dengan frekuensi natural $\omega = \sqrt{k/m}$ dan rasio redaman $\zeta = \frac{c}{2\sqrt{km}}$.

Representasi State-Space:

```python
def msdstatespace(m, c, k):
    A = np.array([[0, 1], [-k/m, -c/m]])
    B = np.array([[0], [1/m]])
    C = np.array([[1, 0]])
    D = np.array([[0]])
    return ct.ss(A, B, C, D)

sysss = msdstatespace(m, c, k)
print("State-Space representation:")
print(sysss)

eigenvalues = np.linalg.eig(sysss.A)[0]
print(f"Eigenvalues: {eigenvalues}")
```

Variabel keadaan dalam representasi ini adalah posisi $x1 = x$ dan kecepatan $x2 = \dot{x}$.

### Sistem Elektrik (Rangkaian RC)

Rangkaian RC adalah sistem elektrik dasar yang terdiri dari resistor dan kapasitor. Sistem ini umum digunakan sebagai filter dan dalam berbagai aplikasi signal processing.

Analisis Rangkaian:

Berdasarkan hukum Kirchhoff untuk tegangan (KVL):

$$
V{in}(t) = VR(t) + VC(t) = R \cdot i(t) + VC(t)
$$

Hubungan arus-tegangan untuk kapasitor:

$$
i(t) = C \frac{dVC(t)}{dt}
$$

Substitusi memberikan persamaan diferensial:

$$
RC\frac{dVC(t)}{dt} + VC(t) = V{in}(t)
$$

Fungsi Alih:

Transformasi Laplace menghasilkan:

$$
H(s) = \frac{VC(s)}{V{in}(s)} = \frac{1}{RCs + 1} = \frac{1/RC}{s + 1/RC}
$$

Implementasi Python:

```python
def rccircuit(R, C):
    tau = R * C
    num = [1]
    den = [tau, 1]
    return ct.tf(num, den)

R = 1000
C = 1e-6
tau = R * C

Hrc = rccircuit(R, C)
print(f"RC Circuit TF: {Hrc}")
print(f"Time constant (τ): {tau:.6f} s")

cutofffreq = 1 / (2 * np.pi * tau)
print(f"Cutoff frequency: {cutofffreq:.2f} Hz")
```

Rangkaian RC bertindak sebagai low-pass filter dengan konstanta waktu $\tau = RC$ dan frekuensi cutoff $fc = \frac{1}{2\pi RC}$.

### Sistem Proses Industri (Tangki Air)

Sistem tangki air adalah contoh sistem proses industri yang melibatkan dinamika fluida. Sistem ini menunjukkan karakteristik nonlinear yang dapat dilinearisasi untuk analisis.

Pemodelan Fisik:

Berdasarkan prinsip kekekalan massa, laju perubahan volume air dalam tangki adalah:

$$
\frac{dV}{dt} = Q{in} - Q{out}
$$

Untuk tangki silinder dengan area penampang $A$:

$$
A\frac{dh}{dt} = Q{in} - Q{out}
$$

Aliran keluar melalui orifice mengikuti persamaan Torricelli:

$$
Q{out} = Cd A0 \sqrt{2gh}
$$

dimana $Cd$ adalah koefisien discharge, $A0$ adalah area orifice, dan $h$ adalah tinggi air.

Linearisasi:

Di sekitar titik operasi $h0$, linearisasi memberikan:

$$
A\frac{d\Delta h}{dt} = \Delta Q{in} - \frac{Cd A0 \sqrt{2g}}{2\sqrt{h0}} \Delta h
$$

Dengan konstanta waktu $\tau = \frac{2A\sqrt{h0}}{Cd A0 \sqrt{2g}}$ dan gain $K = 1$:

$$
H(s) = \frac{\Delta h(s)}{\Delta Q{in}(s)} = \frac{K}{\tau s + 1}
$$

Implementasi Python:

```python
def watertank(A, Cd, A0, h0, g=9.81):
    tau = (2 * A * np.sqrt(h0)) / (Cd * A0 * np.sqrt(2 * g))
    K = 1
    return ct.tf([K], [tau, 1]), tau

A = 1.0
Cd = 0.6
A0 = 0.01
h0 = 2.0

Htank, tau = watertank(A, Cd, A0, h0)
print(f"Water Tank TF: {Htank}")
print(f"Time constant: {tau:.2f} s")
```

Sistem tangki air menunjukkan bahwa konstanta waktu bergantung pada titik operasi, mencerminkan sifat nonlinear sistem asli.

### Sistem Motor DC

Motor DC adalah aktuator yang umum digunakan dalam sistem kendali. Model motor DC menunjukkan hubungan antara tegangan input dan berbagai output seperti arus, kecepatan, atau posisi.

Pemodelan Elektrik:

Persamaan tegangan untuk rangkaian armatur:

$$
Va(t) = Ra ia(t) + La \frac{dia(t)}{dt} + eb(t)
$$

dimana $eb(t) = Kb \omega(t)$ adalah back EMF.

Pemodelan Mekanik:

Persamaan torsi:

$$
J\frac{d\omega(t)}{dt} + B\omega(t) = Kt ia(t) - TL(t)
$$

dimana $J$ adalah inersia, $B$ adalah koefisien gesekan viscous, dan $TL$ adalah beban torsi.

Fungsi Alih:

Dengan mengabaikan induktansi armatur ($La \approx 0$) dan tanpa beban ($TL = 0$):

$$
H(s) = \frac{\Omega(s)}{Va(s)} = \frac{Kt}{(Ra + Kt Kb)(Js + B) + Kt Kb}
$$

Untuk posisi output: $H{pos}(s) = \frac{H(s)}{s}$

Implementasi Python:

```python
def dcmotor(Ra, La, Kt, Kb, J, B):
    if La == 0:
        num = [Kt]
        den = [Ra*J, Ra*B + Kt*Kb]
    else:
        num = [Kt]
        den = [Ra*La*J, Ra*(La*B + J*Ra) + La*Kt*Kb, Ra*B + Kt*Kb]

    return ct.tf(num, den)

def dcmotorposition(Ra, La, Kt, Kb, J, B):
    Hspeed = dcmotor(Ra, La, Kt, Kb, J, B)
    Hpos = ct.series(Hspeed, ct.tf([1], [1, 0]))
    return Hpos, Hspeed

Ra = 2.0
La = 0.5e-3
Kt = 0.01
Kb = 0.01
J = 0.01
B = 0.1

Hpos, Hspeed = dcmotorposition(Ra, La, Kt, Kb, J, B)

print("DC Motor Transfer Functions:")
print(f"Speed TF: {Hspeed}")
print(f"Position TF: {Hpos}")

polesspeed = ct.pole(Hspeed)
polespos = ct.pole(Hpos)
print(f"Speed TF poles: {polesspeed}")
print(f"Position TF poles: {polespos}")

motorss = ct.ss(Hspeed)
print("\nState-Space representation (speed):")
print(motorss)
```

Model motor DC menunjukkan sistem orde 2 untuk kecepatan dan orde 3 untuk posisi (dengan integrator tambahan).

[@tbl:physical-systems] merangkum karakteristik sistem fisik yang telah dimodelkan.

| Sistem            | Orde | Konstanta Waktu                              | Karakteristik Utama                 |
| ----------------- | ---- | -------------------------------------------- | ----------------------------------- |
| Massa-Pegas-Redam | 2    | $\tau = \frac{2\zeta}{\omega}$              | Osilasi teredam                     |
| Rangkaian RC      | 1    | $\tau = RC$                                  | Eksponensial orde-1                 |
| Tangki Air        | 1    | $\tau = \frac{2A\sqrt{h0}}{Cd A0 \sqrt{2g}}$ | Nonlinear, bergantung titik operasi |
| Motor DC          | 2/3  | Kompleks                                     | Elektro-mekanik                     |

: Karakteristik Sistem Fisik yang Dimodelkan {#tbl:physical-systems}

## Validasi Model

Validasi model adalah proses verifikasi bahwa model matematis yang dikembangkan secara akurat merepresentasikan perilaku sistem fisik dalam rentang operasi yang diinginkan. Proses ini penting untuk memastikan bahwa model dapat digunakan dengan percaya diri untuk analisis dan desain.

### Metode Validasi

#### 1. Validasi Struktural

Validasi struktural memverifikasi bahwa struktur model konsisten dengan pemahaman fisik sistem:

```python
def structuralvalidation():
    H = ct.tf([1], [1, 2, 1])

    poles = ct.pole(H)
    print(f"Poles: {poles}")

    if np.all(np.real(poles) < 0):
        print("[OK] System is stable (all poles in LHP)")
    else:
        print("[ERROR] System is unstable")

    dcgain = ct.dcgain(H)
    print(f"DC Gain: {dcgain}")

    stepinfo = ct.stepinfo(H)
    for key, value in stepinfo.items():
        print(f"{key}: {value:.3f}")

structuralvalidation()
```

#### 2. Validasi Fungsional

Validasi fungsional membandingkan respons model dengan data eksperimen:

```python
def functionalvalidation():
    texp = np.array([0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0])
    yexp = np.array([0, 0.393, 0.632, 0.777, 0.865, 0.918, 0.950])

    Hmodel = ct.tf([1], [1, 1])
    tsim, ysim = ct.stepresponse(Hmodel, texp)

    plt.figure(figsize=(10, 6))
    plt.plot(texp, yexp, 'ro-', label='Experimental Data')
    plt.plot(tsim, ysim, 'b-', label='Model Simulation')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.title('Model Validation')
    plt.legend()
    plt.grid(True)
    plt.show()

    mse = np.mean((yexp - ysim)2)
    print(f"Mean Squared Error: {mse:.6f}")

    correlation = np.corrcoef(yexp, ysim)[0, 1]
    print(f"Correlation coefficient: {correlation:.3f}")

functionalvalidation()
```

#### 3. Validasi Prediktif

Validasi prediktif menguji kemampuan model untuk memprediksi respons terhadap input yang berbeda:

```python
def predictivevalidation():
    H = ct.tf([2], [1, 3, 2])

    testinputs = [
        ("Step", lambda t: np.oneslike(t)),
        ("Ramp", lambda t: t),
        ("Sinusoidal", lambda t: np.sin(2*np.pi*t))
    ]

    t = np.linspace(0, 5, 1000)

    plt.figure(figsize=(15, 5))

    for i, (name, inputfunc) in enumerate(testinputs):
        u = inputfunc(t)
        tout, y = ct.forcedresponse(H, t, u)

        plt.subplot(1, 3, i+1)
        plt.plot(t, u, 'r--', label='Input', alpha=0.7)
        plt.plot(tout, y, 'b-', label='Output')
        plt.title(f'{name} Response')
        plt.xlabel('Time [s]')
        plt.ylabel('Amplitude')
        plt.legend()
        plt.grid(True)

    plt.tightlayout()
    plt.show()

predictivevalidation()
```

### Metrik Validasi

```python
def validationmetrics(yexperimental, ymodel):
    n = len(yexperimental)

    mse = np.mean((yexperimental - ymodel)2)
    rmse = np.sqrt(mse)
    mae = np.mean(np.abs(yexperimental - ymodel))

    ssres = np.sum((yexperimental - ymodel)2)
    sstot = np.sum((yexperimental - np.mean(yexperimental))2)
    rsquared = 1 - (ssres / sstot)

    mape = np.mean(np.abs((yexperimental - ymodel) / yexperimental)) * 100

    print("Validation Metrics:")
    print(f"MSE (Mean Squared Error): {mse:.6f}")
    print(f"RMSE (Root Mean Squared Error): {rmse:.6f}")
    print(f"MAE (Mean Absolute Error): {mae:.6f}")
    print(f"R² (Coefficient of Determination): {rsquared:.3f}")
    print(f"MAPE (Mean Absolute Percentage Error): {mape:.2f}%")

    return {'MSE': mse, 'RMSE': rmse, 'MAE': mae, 'R2': rsquared, 'MAPE': mape}

yexp = np.array([0, 0.393, 0.632, 0.777, 0.865, 0.918, 0.950])
ymod = np.array([0, 0.393, 0.632, 0.777, 0.865, 0.918, 0.950])

metrics = validationmetrics(yexp, ymod)
```

### Analisis Sensitivitas

Analisis sensitivitas mengevaluasi bagaimana perubahan parameter model mempengaruhi respons sistem:

```python
def sensitivityanalysis():
    nominalparams = {'tau': 1.0, 'K': 1.0}
    paramvariations = np.linspace(0.8, 1.2, 5)

    plt.figure(figsize=(12, 8))

    for i, paramname in enumerate(['tau', 'K']):
        plt.subplot(2, 2, i+1)

        for variation in paramvariations:
            params = nominalparams.copy()
            params[paramname] = variation

            H = ct.tf([params['K']], [params['tau'], 1])
            t, y = ct.stepresponse(H)

            plt.plot(t, y, label=f"{paramname}={variation:.1f}")

        plt.title(f'Sensitivity to {paramname}')
        plt.xlabel('Time [s]')
        plt.ylabel('Output')
        plt.legend()
        plt.grid(True)

    plt.subplot(2, 1, 2)

    sensitivitytau = []
    sensitivityK = []

    for variation in paramvariations:
        paramstau = nominalparams.copy()
        paramstau['tau'] = variation
        Htau = ct.tf([paramstau['K']], [paramstau['tau'], 1])

        paramsK = nominalparams.copy()
        paramsK['K'] = variation
        HK = ct.tf([paramsK['K']], [paramsK['tau'], 1])

        dcgaintau = ct.dcgain(Htau)
        dcgainK = ct.dcgain(HK)

        sensitivitytau.append(dcgaintau)
        sensitivityK.append(dcgainK)

    plt.plot(paramvariations, sensitivitytau, 'o-', label='τ variation')
    plt.plot(paramvariations, sensitivityK, 's-', label='K variation')
    plt.xlabel('Parameter Variation Factor')
    plt.ylabel('DC Gain')
    plt.title('Parameter Sensitivity Analysis')
    plt.legend()
    plt.grid(True)

    plt.tightlayout()
    plt.show()

sensitivityanalysis()
```

Dengan menyelesaikan proses pemodelan yang komprehensif ini, pembaca memiliki fondasi yang kuat untuk menganalisis sistem kendali dalam domain waktu dan frekuensi pada bab-bab selanjutnya. Pemahaman mendalam tentang pemodelan sistem akan memungkinkan implementasi kontroler yang efektif dan analisis performa yang akurat.

