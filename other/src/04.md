# Analisis Domain Waktu

Analisis domain waktu merupakan metode fundamental untuk evaluasi performa sistem kendali dengan mengamati respons output terhadap variasi input dalam fungsi waktu. Pendekatan ini memberikan pemahaman intuitif tentang bagaimana sistem berperilaku dalam kondisi operasi nyata dan menjadi dasar untuk desain kontroler yang efektif.

Dalam analisis domain waktu, performa sistem dievaluasi berdasarkan karakteristik respons temporal seperti kecepatan respons, stabilitas, dan akurasi steady-state. Metode ini sangat penting karena memberikan gambaran langsung tentang bagaimana sistem akan beroperasi dalam aplikasi praktis, dimana waktu menjadi faktor kritis dalam menentukan kualitas kendali.

## Konsep Dasar Analisis Domain Waktu

Analisis domain waktu mempelajari bagaimana sistem kendali merespons berbagai jenis input sebagai fungsi waktu. Pendekatan ini memungkinkan insinyur untuk memahami karakteristik dinamis sistem dan mengevaluasi apakah performa sistem memenuhi spesifikasi yang diinginkan.

### Pentingnya Analisis Domain Waktu

Respons waktu menjadi parameter kritis dalam sistem kendali karena beberapa alasan mendasar:

1. Evaluasi Performa Praktis: Memberikan gambaran langsung tentang bagaimana sistem beroperasi dalam kondisi nyata
2. Desain Spesifikasi: Memungkinkan penetapan kriteria performa yang terukur dan dapat diverifikasi
3. Validasi Sistem: Menyediakan metode untuk memvalidasi apakah sistem memenuhi persyaratan operasional
4. Optimasi Parameter: Membantu dalam penyetelan parameter kontroler untuk mencapai performa optimal

### Hubungan Input-Output dalam Domain Waktu

Untuk sistem linear time-invariant (LTI), hubungan antara input $u(t)$ dan output $y(t)$ dapat dinyatakan melalui convolution integral:

$$
y(t) = \int0^t h(\tau) u(t-\tau) d\tau
$$

dimana $h(t)$ adalah respons impuls sistem. Hubungan ini menunjukkan bahwa output sistem pada waktu tertentu bergantung pada seluruh riwayat input yang telah diberikan.

```python
import numpy as np
import control as ct
import matplotlib.pyplot as plt

def demonstrateconvolution():
    H = ct.tf([2], [1, 3, 2])

    t = np.linspace(0, 5, 1000)
    timpulse, h = ct.impulseresponse(H, t)

    inputsignal = np.sin(2*np.pi*0.5*t)
    toutput, yconv = ct.forcedresponse(H, t, inputsignal)

    plt.figure(figsize=(12, 8))

    plt.subplot(3, 1, 1)
    plt.plot(timpulse, h)
    plt.title('Impulse Response h(t)')
    plt.xlabel('Time [s]')
    plt.ylabel('Amplitude')
    plt.grid(True)

    plt.subplot(3, 1, 2)
    plt.plot(t, inputsignal)
    plt.title('Input Signal u(t)')
    plt.xlabel('Time [s]')
    plt.ylabel('Amplitude')
    plt.grid(True)

    plt.subplot(3, 1, 3)
    plt.plot(toutput, yconv)
    plt.title('Output Signal y(t) = h(t) * u(t)')
    plt.xlabel('Time [s]')
    plt.ylabel('Amplitude')
    plt.grid(True)

    plt.tightlayout()
    plt.show()

demonstrateconvolution()
```

Kode di atas mendemonstrasikan bagaimana output sistem diperoleh dari convolution antara respons impuls dan sinyal input. Konsep ini fundamental dalam memahami bagaimana sistem memproses sinyal dalam domain waktu.

### Linearitas dan Superposisi

Sistem linear memenuhi prinsip superposisi, yang menyatakan bahwa respons terhadap kombinasi input adalah kombinasi linear dari respons individual:

$$
\text{Jika } u(t) = a1 u1(t) + a2 u2(t), \text{ maka } y(t) = a1 y1(t) + a2 y2(t)
$$

```python
def demonstratesuperposition():
    H = ct.tf([1], [1, 2, 1])

    t = np.linspace(0, 8, 1000)

    u1 = np.oneslike(t)
    u2 = t
    ucombined = 2*u1 + 0.5*u2

    t1, y1 = ct.forcedresponse(H, t, u1)
    t2, y2 = ct.forcedresponse(H, t, u2)
    tcombined, ycombined = ct.forcedresponse(H, t, ucombined)
    ysuperposition = 2*y1 + 0.5*y2

    plt.figure(figsize=(14, 10))

    plt.subplot(2, 2, 1)
    plt.plot(t1, y1, label='Response to u₁(t)')
    plt.title('Individual Response 1')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.grid(True)
    plt.legend()

    plt.subplot(2, 2, 2)
    plt.plot(t2, y2, label='Response to u₂(t)')
    plt.title('Individual Response 2')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.grid(True)
    plt.legend()

    plt.subplot(2, 2, 3)
    plt.plot(tcombined, ycombined, 'b-', label='Actual Response')
    plt.plot(t, ysuperposition, 'r--', label='Superposition')
    plt.title('Superposition Verification')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.grid(True)
    plt.legend()

    plt.subplot(2, 2, 4)
    error = np.abs(ycombined - ysuperposition)
    plt.plot(t, error)
    plt.title('Superposition Error')
    plt.xlabel('Time [s]')
    plt.ylabel('Error')
    plt.grid(True)

    plt.tightlayout()
    plt.show()

    maxerror = np.max(error)
    print(f"Maximum superposition error: {maxerror:.2e}")

demonstratesuperposition()
```

Demonstrasi ini memverifikasi bahwa prinsip superposisi berlaku untuk sistem linear, dengan error yang sangat kecil akibat keterbatasan numerik.

## Jenis Respons Domain Waktu

Analisis respons sistem terhadap berbagai jenis input standar memberikan wawasan komprehensif tentang karakteristik dinamis sistem. Setiap jenis input mengungkap aspek berbeda dari perilaku sistem.

### Respons Step

Respons step adalah respons sistem terhadap input step unit yang didefinisikan sebagai:

$$
u(t) = \begin{cases}
0 & t < 0 \\
1 & t \geq 0
\end{cases}
$$

Respons step sangat penting karena memberikan informasi tentang stabilitas, kecepatan respons, dan akurasi steady-state sistem.

```python
def analyzestepresponse():
    systems = {
        'First Order': ct.tf([1], [1, 1]),
        'Second Order (Underdamped)': ct.tf([1], [1, 0.4, 1]),
        'Second Order (Critically Damped)': ct.tf([1], [1, 2, 1]),
        'Second Order (Overdamped)': ct.tf([1], [1, 3, 1])
    }

    plt.figure(figsize=(14, 10))

    for i, (name, H) in enumerate(systems.items(), 1):
        t, y = ct.stepresponse(H)

        plt.subplot(2, 2, i)
        plt.plot(t, y, 'b-', linewidth=2)
        plt.title(f'{name} Step Response')
        plt.xlabel('Time [s]')
        plt.ylabel('Output')
        plt.grid(True)

        stepinfo = ct.stepinfo(H)
        infotext = f"Rise Time: {stepinfo['RiseTime']:.2f}s\n"
        infotext += f"Settling Time: {stepinfo['SettlingTime']:.2f}s\n"
        if 'Overshoot' in stepinfo:
            infotext += f"Overshoot: {stepinfo['Overshoot']:.1f}%"

        plt.text(0.02, 0.98, infotext, transform=plt.gca().transAxes,
                verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat'))

    plt.tightlayout()
    plt.show()

    return systems

systems = analyzestepresponse()
```

Respons step mengungkap karakteristik fundamental sistem seperti rise time, settling time, overshoot, dan nilai steady-state. Informasi ini crucial untuk mengevaluasi apakah sistem memenuhi spesifikasi performa.

### Respons Impuls

Respons impuls adalah respons sistem terhadap input impuls Dirac $\delta(t)$. Respons ini identik dengan impulse response function $h(t)$ yang merupakan karakteristik intrinsik sistem.

```python
def analyzeimpulseresponse():
    H1 = ct.tf([2], [1, 1])
    H2 = ct.tf([4], [1, 2, 4])
    H3 = ct.tf([1, 2], [1, 3, 3, 1])

    systems = [H1, H2, H3]
    names = ['First Order', 'Second Order', 'Third Order']

    plt.figure(figsize=(15, 5))

    for i, (H, name) in enumerate(zip(systems, names)):
        t, y = ct.impulseresponse(H)

        plt.subplot(1, 3, i+1)
        plt.plot(t, y, 'r-', linewidth=2)
        plt.title(f'{name} Impulse Response')
        plt.xlabel('Time [s]')
        plt.ylabel('h(t)')
        plt.grid(True)

        poles = ct.pole(H)
        polestext = f"Poles: {poles}"
        plt.text(0.02, 0.98, polestext, transform=plt.gca().transAxes,
                verticalalignment='top', fontsize=8,
                bbox=dict(boxstyle='round', facecolor='lightcyan'))

    plt.tightlayout()
    plt.show()

analyzeimpulseresponse()
```

Respons impuls memberikan informasi tentang dinamika internal sistem dan dapat digunakan untuk menganalisis stabilitas melalui bentuk peluruhan responnya.

### Respons Ramp

Respons ramp adalah respons sistem terhadap input ramp yang didefinisikan sebagai:

$$
u(t) = \begin{cases}
0 & t < 0 \\
t & t \geq 0
\end{cases}
$$

Respons ramp sangat berguna untuk mengevaluasi kemampuan sistem dalam mengikuti input yang berubah secara linear dengan waktu.

```python
def analyzerampresponse():
    systems = {
        'Type 0 System': ct.tf([1], [1, 1]),
        'Type 1 System': ct.tf([1], [1, 1, 0]),
        'Type 2 System': ct.tf([1], [1, 1, 0, 0])
    }

    t = np.linspace(0, 10, 1000)
    rampinput = t

    plt.figure(figsize=(15, 5))

    for i, (name, H) in enumerate(systems.items(), 1):
        try:
            tout, y = ct.forcedresponse(H, t, rampinput)

            plt.subplot(1, 3, i)
            plt.plot(t, rampinput, 'g--', label='Ramp Input', alpha=0.7)
            plt.plot(tout, y, 'b-', label='System Output', linewidth=2)
            plt.title(f'{name}')
            plt.xlabel('Time [s]')
            plt.ylabel('Amplitude')
            plt.grid(True)
            plt.legend()

            if len(tout) > 100:
                steadystateerror = rampinput[-1] - y[-1]
                errortext = f"SS Error: {steadystateerror:.2f}"
                plt.text(0.02, 0.98, errortext, transform=plt.gca().transAxes,
                        verticalalignment='top',
                        bbox=dict(boxstyle='round', facecolor='yellow'))

        except Exception as e:
            plt.subplot(1, 3, i)
            plt.text(0.5, 0.5, f'Unstable or\nNon-causal',
                    transform=plt.gca().transAxes,
                    horizontalalignment='center',
                    verticalalignment='center',
                    fontsize=14)
            plt.title(f'{name}')

    plt.tightlayout()
    plt.show()

analyzerampresponse()
```

Respons ramp mengungkap steady-state error sistem untuk input yang berubah secara konstan, yang terkait dengan tipe sistem (system type).

### Respons terhadap Sinyal Arbitrer

Sistem kendali sering beroperasi dengan input yang kompleks dan tidak dapat diprediksi. Analisis respons terhadap sinyal arbitrer memberikan pemahaman tentang bagaimana sistem menangani input realistis.

```python
def analyzearbitraryresponse():
    H = ct.tf([2], [1, 2, 2])

    t = np.linspace(0, 15, 1500)

    # Different input types
    inputs = {
        'Sinusoidal': np.sin(2*np.pi*0.3*t),
        'Chirp': np.sin(2*np.pi*0.1*t2),
        'Square Wave': np.sign(np.sin(2*np.pi*0.2*t)),
        'Random': np.random.normal(0, 0.5, len(t))
    }

    plt.figure(figsize=(16, 12))

    for i, (inputname, inputsignal) in enumerate(inputs.items(), 1):
        tout, y = ct.forcedresponse(H, t, inputsignal)

        plt.subplot(4, 2, 2*i-1)
        plt.plot(t, inputsignal, 'r-', alpha=0.7)
        plt.title(f'{inputname} Input')
        plt.xlabel('Time [s]')
        plt.ylabel('Amplitude')
        plt.grid(True)

        plt.subplot(4, 2, 2*i)
        plt.plot(tout, y, 'b-')
        plt.title(f'{inputname} Response')
        plt.xlabel('Time [s]')
        plt.ylabel('Output')
        plt.grid(True)

    plt.tightlayout()
    plt.show()

analyzearbitraryresponse()
```

Analisis respons terhadap berbagai jenis sinyal menunjukkan bagaimana sistem memfilter, meredam, atau mengamplifikasi komponen frekuensi yang berbeda dari input.

## Parameter Kinerja Domain Waktu

Parameter kinerja domain waktu adalah metrik kuantitatif yang digunakan untuk mengevaluasi kualitas respons sistem. Parameter-parameter ini menjadi standar dalam spesifikasi dan evaluasi sistem kendali.

### Parameter Respons Step

Untuk respons step, terdapat beberapa parameter kinerja standar yang digunakan secara universal:

```python
def detailedstepanalysis():
    H = ct.tf([1], [1, 0.6, 1])

    t, y = ct.stepresponse(H)
    stepinfo = ct.stepinfo(H)

    plt.figure(figsize=(14, 10))

    # Main step response plot
    plt.subplot(2, 2, 1)
    plt.plot(t, y, 'b-', linewidth=2, label='Step Response')

    # Rise time markers
    if 'RiseTime' in stepinfo:
        risetime = stepinfo['RiseTime']
        y10 = 0.1 * stepinfo['SteadyStateValue']
        y90 = 0.9 * stepinfo['SteadyStateValue']

        plt.axhline(y=y10, color='g', linestyle='--', alpha=0.7, label='10%')
        plt.axhline(y=y90, color='g', linestyle='--', alpha=0.7, label='90%')
        plt.axvline(x=risetime, color='g', linestyle=':', alpha=0.7, label=f'Rise Time: {risetime:.2f}s')

    # Settling time
    if 'SettlingTime' in stepinfo:
        settlingtime = stepinfo['SettlingTime']
        steadystate = stepinfo['SteadyStateValue']
        settlingbandupper = steadystate * 1.02
        settlingbandlower = steadystate * 0.98

        plt.axhline(y=settlingbandupper, color='orange', linestyle='--', alpha=0.7)
        plt.axhline(y=settlingbandlower, color='orange', linestyle='--', alpha=0.7)
        plt.axvline(x=settlingtime, color='orange', linestyle=':', alpha=0.7,
                   label=f'Settling Time: {settlingtime:.2f}s')

    # Peak overshoot
    if 'Peak' in stepinfo:
        peaktime = stepinfo['PeakTime']
        peakvalue = stepinfo['Peak']
        plt.plot(peaktime, peakvalue, 'ro', markersize=8, label=f'Peak: {peakvalue:.3f}')

    plt.title('Step Response Analysis')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.grid(True)
    plt.legend()

    # Error analysis
    plt.subplot(2, 2, 2)
    steadystate = stepinfo['SteadyStateValue']
    error = 1 - y  # Error from unit step
    plt.plot(t, error, 'r-', linewidth=2)
    plt.title('Step Error vs Time')
    plt.xlabel('Time [s]')
    plt.ylabel('Error')
    plt.grid(True)

    # Parameters summary
    plt.subplot(2, 2, 3)
    plt.axis('off')
    paramtext = "Step Response Parameters:\n\n"
    for key, value in stepinfo.items():
        if isinstance(value, (int, float)):
            paramtext += f"{key}: {value:.4f}\n"
        else:
            paramtext += f"{key}: {value}\n"

    plt.text(0.1, 0.9, paramtext, transform=plt.gca().transAxes,
             verticalalignment='top', fontsize=11,
             bbox=dict(boxstyle='round', facecolor='lightblue'))

    # Pole-zero map
    plt.subplot(2, 2, 4)
    poles = ct.pole(H)
    zeros = ct.zero(H)

    plt.plot(np.real(poles), np.imag(poles), 'bx', markersize=10, markeredgewidth=2, label='Poles')
    if len(zeros) > 0:
        plt.plot(np.real(zeros), np.imag(zeros), 'ro', markersize=8, label='Zeros')

    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)
    plt.title('Pole-Zero Map')
    plt.xlabel('Real Part')
    plt.ylabel('Imaginary Part')
    plt.grid(True)
    plt.legend()

    plt.tightlayout()
    plt.show()

    return stepinfo

stepinfo = detailedstepanalysis()
```

[@tbl:step-parameters] merangkum definisi parameter kinerja respons step yang paling umum digunakan.

| Parameter          | Definisi                                       | Signifikansi           |
| ------------------ | ---------------------------------------------- | ---------------------- |
| Rise Time          | Waktu untuk naik dari 10% ke 90% nilai akhir   | Kecepatan respons awal |
| Settling Time      | Waktu mencapai dan tetap dalam ±2% nilai akhir | Waktu stabilisasi      |
| Peak Time          | Waktu mencapai nilai maksimum pertama          | Karakteristik osilasi  |
| Overshoot          | Persentase nilai puncak melebihi nilai akhir   | Stabilitas relatif     |
| Steady-State Error | Perbedaan antara nilai akhir dan referensi     | Akurasi sistem         |

: Parameter Kinerja Respons Step {#tbl:step-parameters}

### Analisis Error Steady-State

Error steady-state adalah perbedaan antara nilai output akhir sistem dengan nilai referensi yang diinginkan. Error ini bergantung pada tipe sistem dan jenis input.

```python
def steadystateerroranalysis():
    # Different system types
    systems = {
        'Type 0': ct.tf([5], [1, 2, 5]),
        'Type 1': ct.tf([5], [1, 2, 5, 0]),
        'Type 2': ct.tf([5], [1, 2, 5, 0, 0])
    }

    inputtypes = ['step', 'ramp', 'parabolic']

    plt.figure(figsize=(15, 10))

    # Calculate theoretical steady-state errors
    results = {}

    for sysname, H in systems.items():
        results[sysname] = {}

        # Step input error
        try:
            essstep = 1 / (1 + ct.dcgain(H))
            results[sysname]['step'] = essstep
        except:
            results[sysname]['step'] = float('inf')

        # Ramp input error
        try:
            # For ramp, we need the velocity error constant
            Hmodified = ct.tf(H.num, H.den)
            s = ct.tf([1, 0], [1])
            Kv = ct.dcgain(Hmodified * s)
            essramp = 1 / Kv if Kv != 0 else float('inf')
            results[sysname]['ramp'] = essramp
        except:
            results[sysname]['ramp'] = float('inf')

        # Parabolic input error
        try:
            s = ct.tf([1, 0], [1])
            Ka = ct.dcgain(Hmodified * s * s)
            essparabolic = 1 / Ka if Ka != 0 else float('inf')
            results[sysname]['parabolic'] = essparabolic
        except:
            results[sysname]['parabolic'] = float('inf')

    # Simulate step responses
    for i, (sysname, H) in enumerate(systems.items(), 1):
        plt.subplot(2, 3, i)
        t, y = ct.stepresponse(H)
        plt.plot(t, y, 'b-', linewidth=2)
        plt.axhline(y=1, color='r', linestyle='--', alpha=0.7, label='Reference')
        plt.title(f'{sysname} System - Step Response')
        plt.xlabel('Time [s]')
        plt.ylabel('Output')
        plt.grid(True)
        plt.legend()

        if results[sysname]['step'] != float('inf'):
            esstext = f"ess = {results[sysname]['step']:.3f}"
        else:
            esstext = "ess = ∞"
        plt.text(0.02, 0.98, esstext, transform=plt.gca().transAxes,
                verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='yellow'))

    # Error summary table
    plt.subplot(2, 1, 2)
    plt.axis('off')

    # Create error table text
    tabletext = "Steady-State Error Summary:\n\n"
    tabletext += f"{'System Type':<12} {'Step Input':<12} {'Ramp Input':<12} {'Parabolic Input':<15}\n"
    tabletext += "-" * 55 + "\n"

    for sysname in systems.keys():
        steperr = f"{results[sysname]['step']:.3f}" if results[sysname]['step'] != float('inf') else "∞"
        ramperr = f"{results[sysname]['ramp']:.3f}" if results[sysname]['ramp'] != float('inf') else "∞"
        paraerr = f"{results[sysname]['parabolic']:.3f}" if results[sysname]['parabolic'] != float('inf') else "∞"

        tabletext += f"{sysname:<12} {steperr:<12} {ramperr:<12} {paraerr:<15}\n"

    plt.text(0.05, 0.95, tabletext, transform=plt.gca().transAxes,
             verticalalignment='top', fontfamily='monospace',
             bbox=dict(boxstyle='round', facecolor='lightgray'))

    plt.tightlayout()
    plt.show()

    return results

essresults = steadystateerroranalysis()
```

Analisis ini menunjukkan hubungan fundamental antara tipe sistem dan kemampuannya untuk mengikuti berbagai jenis input tanpa error steady-state.

## Analisis Sistem Orde 1 dan Orde 2

Sistem orde 1 dan orde 2 merupakan building blocks fundamental dalam sistem kendali dan muncul secara natural dalam banyak aplikasi fisik. Pemahaman mendalam tentang karakteristik sistem ini essential untuk analisis sistem yang lebih kompleks.

### Sistem Orde 1

Sistem orde 1 memiliki fungsi alih dalam bentuk:

$$
H(s) = \frac{K}{\tau s + 1}
$$

dimana $K$ adalah gain steady-state dan $\tau$ adalah konstanta waktu.

```python
def firstorderanalysis():
    # Different time constants
    timeconstants = [0.5, 1.0, 2.0, 5.0]
    K = 1

    plt.figure(figsize=(16, 12))

    # Step responses
    plt.subplot(2, 3, 1)
    for tau in timeconstants:
        H = ct.tf([K], [tau, 1])
        t, y = ct.stepresponse(H)
        plt.plot(t, y, linewidth=2, label=f'τ = {tau}s')

    plt.title('Step Responses - Different Time Constants')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.grid(True)
    plt.legend()

    # Analytical vs numerical comparison
    plt.subplot(2, 3, 2)
    tau = 2.0
    H = ct.tf([K], [tau, 1])
    tsim, ysim = ct.stepresponse(H)

    # Analytical solution
    tanalytical = np.linspace(0, 15, 1000)
    yanalytical = K * (1 - np.exp(-tanalytical/tau))

    plt.plot(tsim, ysim, 'b-', linewidth=2, label='Numerical')
    plt.plot(tanalytical, yanalytical, 'r--', linewidth=2, label='Analytical')
    plt.title(f'Numerical vs Analytical (τ = {tau}s)')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.grid(True)
    plt.legend()

    # Time constant marking
    plt.axhline(y=K*0.632, color='g', linestyle=':', alpha=0.7, label='63.2% of final value')
    plt.axvline(x=tau, color='g', linestyle=':', alpha=0.7, label=f'τ = {tau}s')

    # Frequency response
    plt.subplot(2, 3, 3)
    w = np.logspace(-2, 2, 1000)
    for tau in timeconstants:
        H = ct.tf([K], [tau, 1])
        mag, phase, omega = ct.bodeplot(H, w, plot=False)
        plt.semilogx(omega, 20*np.log10(mag), linewidth=2, label=f'τ = {tau}s')

    plt.title('Magnitude Response')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)
    plt.legend()

    # Pole locations
    plt.subplot(2, 3, 4)
    for tau in timeconstants:
        pole = -1/tau
        plt.plot(pole, 0, 'x', markersize=10, markeredgewidth=3, label=f'τ = {tau}s')

    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)
    plt.title('Pole Locations')
    plt.xlabel('Real Part')
    plt.ylabel('Imaginary Part')
    plt.grid(True)
    plt.legend()

    # Rise time vs time constant
    plt.subplot(2, 3, 5)
    taurange = np.linspace(0.1, 5, 50)
    risetimes = []

    for tau in taurange:
        H = ct.tf([K], [tau, 1])
        stepinfo = ct.stepinfo(H)
        risetimes.append(stepinfo['RiseTime'])

    plt.plot(taurange, risetimes, 'b-', linewidth=2)
    plt.title('Rise Time vs Time Constant')
    plt.xlabel('Time Constant τ [s]')
    plt.ylabel('Rise Time [s]')
    plt.grid(True)

    # Performance metrics table
    plt.subplot(2, 3, 6)
    plt.axis('off')

    perftext = "First-Order System Characteristics:\n\n"
    perftext += "• Step Response: y(t) = K(1 - e^(-t/τ))\n"
    perftext += "• Time to 63.2% of final value: τ\n"
    perftext += "• Time to 95% of final value: 3τ\n"
    perftext += "• Time to 99% of final value: 5τ\n"
    perftext += "• No overshoot\n"
    perftext += "• Pole location: s = -1/τ\n"
    perftext += "• DC Gain: K\n"
    perftext += "• Bandwidth: 1/τ rad/s"

    plt.text(0.05, 0.95, perftext, transform=plt.gca().transAxes,
             verticalalignment='top', fontsize=11,
             bbox=dict(boxstyle='round', facecolor='lightcyan'))

    plt.tightlayout()
    plt.show()

firstorderanalysis()
```

Sistem orde 1 memiliki karakteristik yang sangat predictable dan sering digunakan sebagai aproksimasi untuk sistem yang lebih kompleks dalam rentang frekuensi tertentu.

### Sistem Orde 2

Sistem orde 2 memiliki fungsi alih dalam bentuk standar:

$$
H(s) = \frac{K\omega^2}{s^2 + 2\zeta\omega s + \omega^2}
$$

dimana $\omega$ adalah frekuensi natural, $\zeta$ adalah rasio redaman, dan $K$ adalah gain steady-state.

```python
def secondorderanalysis():
    wn = 2.0  # Natural frequency
    K = 1     # DC gain

    # Different damping ratios
    dampingratios = [0.1, 0.4, 0.7, 1.0, 2.0]
    dampingnames = ['Underdamped (ζ=0.1)', 'Underdamped (ζ=0.4)',
                     'Underdamped (ζ=0.7)', 'Critically Damped (ζ=1.0)',
                     'Overdamped (ζ=2.0)']

    plt.figure(figsize=(18, 14))

    # Step responses
    plt.subplot(3, 3, 1)
    for zeta, name in zip(dampingratios, dampingnames):
        H = ct.tf([K*wn2], [1, 2*zeta*wn, wn2])
        t, y = ct.stepresponse(H)
        plt.plot(t, y, linewidth=2, label=f'ζ = {zeta}')

    plt.title('Step Responses - Different Damping Ratios')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.grid(True)
    plt.legend()

    # Pole locations
    plt.subplot(3, 3, 2)
    for zeta in dampingratios:
        if zeta < 1:  # Underdamped
            realpart = -zeta * wn
            imagpart = wn * np.sqrt(1 - zeta2)
            plt.plot([realpart, realpart], [imagpart, -imagpart], 'o',
                    markersize=8, label=f'ζ = {zeta}')
        elif zeta == 1:  # Critically damped
            plt.plot(-wn, 0, 's', markersize=8, label=f'ζ = {zeta}')
        else:  # Overdamped
            p1 = -wn * (zeta + np.sqrt(zeta2 - 1))
            p2 = -wn * (zeta - np.sqrt(zeta2 - 1))
            plt.plot([p1, p2], [0, 0], 'x', markersize=8, label=f'ζ = {zeta}')

    # Draw unit circle
    theta = np.linspace(0, 2*np.pi, 100)
    circlex = wn * np.cos(theta)
    circley = wn * np.sin(theta)
    plt.plot(circlex, circley, 'k--', alpha=0.3, label='|s| = ωn')

    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)
    plt.title('Pole Locations')
    plt.xlabel('Real Part')
    plt.ylabel('Imaginary Part')
    plt.grid(True)
    plt.legend()

    # Performance vs damping ratio
    plt.subplot(3, 3, 3)
    zetarange = np.linspace(0.1, 2.0, 50)
    overshoots = []
    risetimes = []
    settlingtimes = []

    for zeta in zetarange:
        H = ct.tf([K*wn2], [1, 2*zeta*wn, wn2])
        try:
            stepinfo = ct.stepinfo(H)
            overshoots.append(stepinfo.get('Overshoot', 0))
            risetimes.append(stepinfo['RiseTime'])
            settlingtimes.append(stepinfo['SettlingTime'])
        except:
            overshoots.append(0)
            risetimes.append(np.nan)
            settlingtimes.append(np.nan)

    plt.plot(zetarange, overshoots, 'r-', linewidth=2, label='Overshoot [%]')
    plt.title('Overshoot vs Damping Ratio')
    plt.xlabel('Damping Ratio ζ')
    plt.ylabel('Overshoot [%]')
    plt.grid(True)
    plt.axvline(x=1, color='k', linestyle='--', alpha=0.5, label='Critical Damping')
    plt.legend()

    # Frequency response
    plt.subplot(3, 3, 4)
    w = np.logspace(-1, 2, 1000)
    for zeta in [0.1, 0.4, 0.7, 1.0]:
        H = ct.tf([K*wn2], [1, 2*zeta*wn, wn2])
        mag, phase, omega = ct.bodeplot(H, w, plot=False)
        plt.semilogx(omega, 20*np.log10(mag), linewidth=2, label=f'ζ = {zeta}')

    plt.axvline(x=wn, color='k', linestyle='--', alpha=0.5, label='ωn')
    plt.title('Magnitude Response')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)
    plt.legend()

    # Time response characteristics
    plt.subplot(3, 3, 5)
    plt.plot(zetarange, np.array(risetimes)*wn, 'g-', linewidth=2, label='Rise Time × ωn')
    plt.plot(zetarange, np.array(settlingtimes)*wn, 'b-', linewidth=2, label='Settling Time × ωn')
    plt.title('Normalized Time Response')
    plt.xlabel('Damping Ratio ζ')
    plt.ylabel('Normalized Time')
    plt.grid(True)
    plt.legend()

    # Underdamped response analysis
    plt.subplot(3, 3, 6)
    zeta = 0.3
    H = ct.tf([K*wn2], [1, 2*zeta*wn, wn2])
    t, y = ct.stepresponse(H)

    # Envelope
    wd = wn * np.sqrt(1 - zeta2)  # Damped frequency
    envelopeupper = K * (1 + np.exp(-zeta*wn*t))
    envelopelower = K * (1 - np.exp(-zeta*wn*t))

    plt.plot(t, y, 'b-', linewidth=2, label='Step Response')
    plt.plot(t, envelopeupper, 'r--', linewidth=1, label='Upper Envelope')
    plt.plot(t, envelopelower, 'r--', linewidth=1, label='Lower Envelope')
    plt.axhline(y=K, color='k', linestyle=':', alpha=0.5, label='Steady State')

    plt.title(f'Underdamped Response (ζ = {zeta})')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.grid(True)
    plt.legend()

    # Analytical formulas
    plt.subplot(3, 3, 7)
    plt.axis('off')

    formulastext = "Second-Order System Formulas:\n\n"
    formulastext += "Transfer Function:\n"
    formulastext += "H(s) = Kωn²/(s² + 2ζωns + ωn²)\n\n"
    formulastext += "For ζ < 1 (Underdamped):\n"
    formulastext += "• ωd = ωn√(1-ζ²)\n"
    formulastext += "• Overshoot = 100×e^(-πζ/√(1-ζ²)) %\n"
    formulastext += "• Peak Time = π/ωd\n"
    formulastext += "• Settling Time ≈ 4/(ζωn)\n\n"
    formulastext += "For ζ = 1 (Critically Damped):\n"
    formulastext += "• No overshoot, fastest response\n\n"
    formulastext += "For ζ > 1 (Overdamped):\n"
    formulastext += "• No overshoot, slower response"

    plt.text(0.05, 0.95, formulastext, transform=plt.gca().transAxes,
             verticalalignment='top', fontsize=10, fontfamily='monospace',
             bbox=dict(boxstyle='round', facecolor='lightyellow'))

    # Performance comparison table
    plt.subplot(3, 3, 8)
    plt.axis('off')

    # Create performance table
    zetatest = [0.3, 0.5, 0.7, 1.0]
    tabledata = []

    for zeta in zetatest:
        H = ct.tf([K*wn2], [1, 2*zeta*wn, wn2])
        stepinfo = ct.stepinfo(H)

        overshoot = stepinfo.get('Overshoot', 0)
        risetime = stepinfo['RiseTime']
        settlingtime = stepinfo['SettlingTime']

        tabledata.append([zeta, overshoot, risetime, settlingtime])

    tabletext = "Performance Comparison:\n\n"
    tabletext += f"{'ζ':<6} {'OS[%]':<8} {'tr[s]':<8} {'ts[s]':<8}\n"
    tabletext += "-" * 32 + "\n"

    for row in tabledata:
        tabletext += f"{row[0]:<6.1f} {row[1]:<8.1f} {row[2]:<8.2f} {row[3]:<8.2f}\n"

    plt.text(0.05, 0.95, tabletext, transform=plt.gca().transAxes,
             verticalalignment='top', fontfamily='monospace',
             bbox=dict(boxstyle='round', facecolor='lightgreen'))

    # Root locus concept
    plt.subplot(3, 3, 9)
    Kvalues = np.logspace(-1, 2, 100)
    zetavalues = []
    wnvalues = []

    for Kval in Kvalues:
        # For varying K in feedback system
        # Assuming plant G(s) = K/(s(s+1))
        poles = np.roots([1, 1, Kval])
        if np.isreal(poles[0]):
            zetavalues.append(2.0)  # Overdamped approximation
            wnvalues.append(np.sqrt(Kval))
        else:
            wn = np.abs(poles[0])
            zeta = -np.real(poles[0]) / wn
            zetavalues.append(zeta)
            wnvalues.append(wn)

    plt.loglog(Kvalues, zetavalues, 'b-', linewidth=2)
    plt.axhline(y=1, color='r', linestyle='--', alpha=0.7, label='Critical Damping')
    plt.title('Damping Ratio vs Controller Gain')
    plt.xlabel('Controller Gain K')
    plt.ylabel('Damping Ratio ζ')
    plt.grid(True)
    plt.legend()

    plt.tightlayout()
    plt.show()

secondorderanalysis()
```

Analisis sistem orde 2 menunjukkan bagaimana rasio redaman mempengaruhi semua aspek respons sistem, dari stabilitas hingga kecepatan respons.

### Perbandingan Karakteristik dan Aplikasi

```python
def comparefirstsecondorder():
    # Define representative systems
    H1 = ct.tf([1], [2, 1])  # First order, tau=2
    H2under = ct.tf([1], [1, 0.6, 1])  # Second order, underdamped
    H2critical = ct.tf([1], [1, 2, 1])  # Second order, critically damped
    H2over = ct.tf([1], [1, 4, 1])  # Second order, overdamped

    systems = [H1, H2under, H2critical, H2over]
    names = ['First Order', 'Second Order\n(Underdamped)',
             'Second Order\n(Critically Damped)', 'Second Order\n(Overdamped)']

    plt.figure(figsize=(16, 12))

    # Step responses comparison
    plt.subplot(2, 3, 1)
    for H, name in zip(systems, names):
        t, y = ct.stepresponse(H)
        plt.plot(t, y, linewidth=2, label=name)

    plt.title('Step Response Comparison')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.grid(True)
    plt.legend()

    # Frequency responses
    plt.subplot(2, 3, 2)
    w = np.logspace(-2, 2, 1000)
    for H, name in zip(systems, names):
        mag, phase, omega = ct.bodeplot(H, w, plot=False)
        plt.semilogx(omega, 20*np.log10(mag), linewidth=2, label=name)

    plt.title('Magnitude Response Comparison')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)
    plt.legend()

    # Performance metrics comparison
    plt.subplot(2, 3, 3)
    plt.axis('off')

    perfdata = []
    for H, name in zip(systems, names):
        stepinfo = ct.stepinfo(H)
        overshoot = stepinfo.get('Overshoot', 0)
        risetime = stepinfo['RiseTime']
        settlingtime = stepinfo['SettlingTime']
        steadystate = stepinfo['SteadyStateValue']

        perfdata.append([name.replace('\n', ' '), overshoot, risetime, settlingtime, steadystate])

    tabletext = "Performance Metrics Comparison:\n\n"
    tabletext += f"{'System':<20} {'OS[%]':<8} {'tr[s]':<8} {'ts[s]':<8} {'SS':<8}\n"
    tabletext += "-" * 60 + "\n"

    for row in perfdata:
        tabletext += f"{row[0]:<20} {row[1]:<8.1f} {row[2]:<8.2f} {row[3]:<8.2f} {row[4]:<8.3f}\n"

    plt.text(0.05, 0.95, tabletext, transform=plt.gca().transAxes,
             verticalalignment='top', fontfamily='monospace', fontsize=9,
             bbox=dict(boxstyle='round', facecolor='lightgray'))

    # Applications and characteristics
    plt.subplot(2, 3, 4)
    plt.axis('off')

    apptext = "Typical Applications:\n\n"
    apptext += "First Order Systems:\n"
    apptext += "• RC circuits\n"
    apptext += "• Thermal systems\n"
    apptext += "• Simple lag processes\n"
    apptext += "• Approximation of complex systems\n\n"
    apptext += "Second Order Systems:\n"
    apptext += "• Mass-spring-damper\n"
    apptext += "• RLC circuits\n"
    apptext += "• Positioning systems\n"
    apptext += "• Structural vibrations\n"
    apptext += "• Control system design"

    plt.text(0.05, 0.95, apptext, transform=plt.gca().transAxes,
             verticalalignment='top', fontsize=11,
             bbox=dict(boxstyle='round', facecolor='lightcyan'))

    # Design guidelines
    plt.subplot(2, 3, 5)
    plt.axis('off')

    designtext = "Design Guidelines:\n\n"
    designtext += "First Order:\n"
    designtext += "• No overshoot\n"
    designtext += "• Predictable response\n"
    designtext += "• Simple tuning (only τ)\n"
    designtext += "• Limited bandwidth\n\n"
    designtext += "Second Order:\n"
    designtext += "• ζ = 0.4-0.7 for good transient\n"
    designtext += "• ζ = 1.0 for fastest no-overshoot\n"
    designtext += "• Higher ωn for faster response\n"
    designtext += "• Trade-off: speed vs overshoot"

    plt.text(0.05, 0.95, designtext, transform=plt.gca().transAxes,
             verticalalignment='top', fontsize=11,
             bbox=dict(boxstyle='round', facecolor='lightyellow'))

    # Pole-zero maps
    plt.subplot(2, 3, 6)
    for H, name in zip(systems, names):
        poles = ct.pole(H)
        zeros = ct.zero(H)

        if len(poles) == 1:  # First order
            plt.plot(np.real(poles), np.imag(poles), 'o', markersize=8, label=name)
        else:  # Second order
            plt.plot(np.real(poles), np.imag(poles), 'x', markersize=8, label=name)

    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)
    plt.title('Pole Locations Comparison')
    plt.xlabel('Real Part')
    plt.ylabel('Imaginary Part')
    plt.grid(True)
    plt.legend()

    plt.tightlayout()
    plt.show()

comparefirstsecondorder()
```

[@tbl:order-comparison] memberikan ringkasan perbandingan karakteristik sistem orde 1 dan orde 2.

| Aspek           | Sistem Orde 1         | Sistem Orde 2                |
| --------------- | --------------------- | ---------------------------- |
| Kompleksitas    | Sederhana             | Lebih kompleks               |
| Parameter       | 2 (K, τ)              | 3 (K, ωn, ζ)                 |
| Overshoot       | Tidak ada             | Bisa ada (ζ < 1)             |
| Osilasi         | Tidak ada             | Bisa ada (ζ < 1)             |
| Tuning          | Mudah                 | Perlu pertimbangan trade-off |
| Aplikasi        | Filter, proses termal | Sistem mekanik, positioning  |
| Respon Tercepat | Eksponensial          | Critically damped (ζ = 1)    |

: Perbandingan Sistem Orde 1 dan Orde 2 {#tbl:order-comparison}

Dengan pemahaman komprehensif tentang analisis domain waktu ini, pembaca memiliki fondasi yang kuat untuk mengevaluasi performa sistem kendali dan memahami bagaimana parameter sistem mempengaruhi karakteristik respons. Konsep-konsep ini akan menjadi dasar untuk analisis domain frekuensi dan desain kontroler pada bab-bab selanjutnya.

