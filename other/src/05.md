# Analisis Domain Frekuensi

Analisis domain frekuensi merupakan metodologi fundamental dalam sistem kendali yang mempelajari bagaimana sistem merespons sinyal sinusoidal pada berbagai frekuensi. Pendekatan ini memberikan wawasan mendalam tentang karakteristik sistem yang sulit diperoleh melalui analisis domain waktu, terutama dalam hal stabilitas, bandwidth, dan margin kestabilan.

Transformasi dari domain waktu ke domain frekuensi memungkinkan insinyur untuk memahami bagaimana sistem memfilter, mengamplifikasi, atau menggeser fase komponen frekuensi yang berbeda dari sinyal input. Pemahaman ini crucial untuk desain kontroler, analisis stabilitas, dan optimasi performa sistem kendali.

## Konsep Dasar Analisis Domain Frekuensi

Analisis domain frekuensi didasarkan pada respons sistem terhadap sinyal sinusoidal. Untuk sistem linear time-invariant (LTI), jika input berupa sinyal sinusoidal $u(t) = A\sin(\omega t + \phi)$, maka output dalam steady-state juga akan berupa sinusoidal dengan frekuensi yang sama tetapi dengan amplitudo dan fase yang berbeda.

### Pentingnya Analisis Frekuensi

Analisis frekuensi memberikan beberapa keunggulan yang tidak dapat diperoleh dari analisis domain waktu:

1. Analisis Stabilitas: Menentukan stabilitas sistem tanpa perlu menghitung poles secara eksplisit
2. Desain Kontroler: Memudahkan desain kontroler dengan spesifikasi bandwidth dan margin kestabilan
3. Analisis Noise: Memahami bagaimana sistem menangani gangguan pada frekuensi tertentu
4. Karakterisasi Sistem: Memberikan gambaran intuitif tentang perilaku sistem pada rentang frekuensi operasi

### Hubungan Domain Waktu dan Frekuensi

Hubungan fundamental antara domain waktu dan frekuensi diberikan oleh transformasi Fourier dan Laplace. Untuk sistem LTI dengan fungsi alih $H(s)$, respons frekuensi diperoleh dengan substitusi $s = j\omega$:

$$H(j\omega) = |H(j\omega)|e^{j\angle H(j\omega)}$$

dimana $|H(j\omega)|$ adalah magnitude dan $\angle H(j\omega)$ adalah fase.

```python
import numpy as np
import control as ct
import matplotlib.pyplot as plt

def demonstratefrequencyresponse():
    H = ct.tf([10], [1, 2, 10])

    w = np.logspace(-1, 2, 1000)
    mag, phase, omega = ct.bodeplot(H, w)

    plt.figure(figsize=(14, 10))

    # Magnitude plot
    plt.subplot(2, 2, 1)
    plt.semilogx(omega, 20*np.log10(mag))
    plt.title('Magnitude Response')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)

    # Phase plot
    plt.subplot(2, 2, 2)
    plt.semilogx(omega, np.degrees(phase))
    plt.title('Phase Response')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Phase [degrees]')
    plt.grid(True)

    # Time domain comparison
    t = np.linspace(0, 5, 1000)
    frequencies = [0.5, 2, 10]

    plt.subplot(2, 1, 2)
    for freq in frequencies:
        u = np.sin(2*np.pi*freq*t)
        tout, y = ct.forcedresponse(H, t, u)

        # Calculate theoretical response
        Hval = ct.evalfr(H, 1j*2*np.pi*freq)
        magtheo = abs(Hval)
        phasetheo = np.angle(Hval)
        ytheo = magtheo * np.sin(2*np.pi*freq*t + phasetheo)

        plt.plot(t, u, '--', alpha=0.5, label=f'Input {freq} Hz')
        plt.plot(tout, y, '-', linewidth=2, label=f'Output {freq} Hz')

    plt.title('Sinusoidal Response at Different Frequencies')
    plt.xlabel('Time [s]')
    plt.ylabel('Amplitude')
    plt.legend()
    plt.grid(True)

    plt.tightlayout()
    plt.show()

demonstratefrequencyresponse()
```

Kode ini mendemonstrasikan bagaimana sistem merespons sinyal sinusoidal pada frekuensi yang berbeda. Respons frekuensi menunjukkan bagaimana magnitude dan fase berubah terhadap frekuensi, sementara simulasi domain waktu memverifikasi prediksi teoritis.

### Representasi Kompleks

Fungsi alih dalam domain frekuensi dapat dinyatakan dalam bentuk kompleks:

$$H(j\omega) = \text{Re}[H(j\omega)] + j\text{Im}[H(j\omega)]$$

atau dalam bentuk polar:

$$H(j\omega) = |H(j\omega)| \angle H(j\omega)$$

```python
def complexrepresentation():
    H = ct.tf([1, 2], [1, 3, 2])
    w = np.logspace(-1, 2, 100)

    plt.figure(figsize=(15, 5))

    # Calculate frequency response
    Hjw = []
    for freq in w:
        Hval = ct.evalfr(H, 1j*freq)
        Hjw.append(Hval)

    Hjw = np.array(Hjw)

    # Real and imaginary parts
    plt.subplot(1, 3, 1)
    plt.semilogx(w, np.real(Hjw), label='Real Part')
    plt.semilogx(w, np.imag(Hjw), label='Imaginary Part')
    plt.title('Real and Imaginary Parts')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Amplitude')
    plt.legend()
    plt.grid(True)

    # Magnitude and phase
    plt.subplot(1, 3, 2)
    plt.semilogx(w, np.abs(Hjw), 'b-', label='Magnitude')
    plt.title('Magnitude')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('|H(jω)|')
    plt.grid(True)

    plt.subplot(1, 3, 3)
    plt.semilogx(w, np.degrees(np.angle(Hjw)), 'r-', label='Phase')
    plt.title('Phase')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('∠H(jω) [degrees]')
    plt.grid(True)

    plt.tightlayout()
    plt.show()

complexrepresentation()
```

Representasi kompleks memberikan pemahaman yang lebih mendalam tentang bagaimana sistem memproses sinyal pada setiap frekuensi.

## Representasi dan Parameter Kinerja Domain Frekuensi

Parameter kinerja domain frekuensi memberikan metrik kuantitatif untuk mengevaluasi karakteristik sistem. Parameter-parameter ini essential dalam spesifikasi desain dan evaluasi performa sistem kendali.

### Parameter Fundamental

#### Magnitude dan Fase

Magnitude menunjukkan seberapa besar sistem mengamplifikasi atau meredam sinyal pada frekuensi tertentu, sedangkan fase menunjukkan time delay yang direpresentasikan sebagai pergeseran fase.

```python
def analyzemagnitudephase():
    systems = {
        'Low-pass Filter': ct.tf([1], [1, 1]),
        'High-pass Filter': ct.tf([1, 0], [1, 1]),
        'Band-pass Filter': ct.tf([1, 0], [1, 1.4, 1]),
        'Notch Filter': ct.tf([1, 0, 1], [1, 0.2, 1])
    }

    w = np.logspace(-2, 2, 1000)

    plt.figure(figsize=(16, 12))

    # Magnitude responses
    plt.subplot(2, 2, 1)
    for name, H in systems.items():
        mag, phase, omega = ct.bodeplot(H, w, plot=False)
        plt.semilogx(omega, 20*np.log10(mag), linewidth=2, label=name)

    plt.title('Magnitude Responses of Different Filter Types')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)
    plt.legend()
    plt.axhline(y=-3, color='k', linestyle='--', alpha=0.5, label='-3dB line')

    # Phase responses
    plt.subplot(2, 2, 2)
    for name, H in systems.items():
        mag, phase, omega = ct.bodeplot(H, w, plot=False)
        plt.semilogx(omega, np.degrees(phase), linewidth=2, label=name)

    plt.title('Phase Responses of Different Filter Types')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Phase [degrees]')
    plt.grid(True)
    plt.legend()

    # Bandwidth calculation
    plt.subplot(2, 2, 3)
    Hexample = ct.tf([10], [1, 1, 10])
    mag, phase, omega = ct.bodeplot(Hexample, w, plot=False)
    magdb = 20*np.log10(mag)

    plt.semilogx(omega, magdb, 'b-', linewidth=2, label='System Response')

    # Find -3dB bandwidth
    dcgaindb = magdb[0]
    cutoffdb = dcgaindb - 3
    cutoffidx = np.where(magdb <= cutoffdb)[0]
    if len(cutoffidx) > 0:
        bandwidth = omega[cutoffidx[0]]
        plt.axhline(y=cutoffdb, color='r', linestyle='--', label='-3dB line')
        plt.axvline(x=bandwidth, color='r', linestyle='--', label=f'Bandwidth: {bandwidth:.2f} rad/s')

    plt.title('Bandwidth Calculation')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)
    plt.legend()

    # Resonant peak
    plt.subplot(2, 2, 4)
    Hresonant = ct.tf([1], [1, 0.2, 1])
    mag, phase, omega = ct.bodeplot(Hresonant, w, plot=False)
    magdb = 20*np.log10(mag)

    plt.semilogx(omega, magdb, 'g-', linewidth=2, label='Underdamped System')

    # Find resonant peak
    peakidx = np.argmax(magdb)
    peakfreq = omega[peakidx]
    peakmag = magdb[peakidx]

    plt.plot(peakfreq, peakmag, 'ro', markersize=8, label=f'Peak: {peakmag:.1f} dB at {peakfreq:.2f} rad/s')
    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)

    plt.title('Resonant Peak Identification')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)
    plt.legend()

    plt.tightlayout()
    plt.show()

analyzemagnitudephase()
```

#### Bandwidth

Bandwidth adalah rentang frekuensi dimana sistem memberikan respons yang dapat diterima. Biasanya didefinisikan sebagai frekuensi dimana magnitude turun 3 dB dari nilai DC atau nilai maksimum.

#### Resonant Peak

Untuk sistem underdamped, resonant peak ($Mr$) adalah nilai maksimum magnitude dalam respons frekuensi. Parameter ini terkait dengan rasio redaman sistem.

### Margin Kestabilan

Margin kestabilan adalah parameter crucial yang menunjukkan seberapa dekat sistem dengan ketidakstabilan.

#### Gain Margin

Gain margin ($GM$) adalah faktor dimana loop gain dapat ditingkatkan sebelum sistem menjadi tidak stabil. Dinyatakan dalam dB:

$$GM = -20\log{10}|H(j\omega{pc})| \text{ dB}$$

dimana $\omega{pc}$ adalah frekuensi phase crossover (fase = -180°).

#### Phase Margin

Phase margin ($PM$) adalah besar fase tambahan yang dapat ditoleransi sebelum sistem tidak stabil:

$$PM = 180° + \angle H(j\omega{gc})$$

dimana $\omega{gc}$ adalah frekuensi gain crossover (magnitude = 0 dB).

```python
def stabilitymargins():
    Kvalues = [0.5, 1, 2, 5]
    Hplant = ct.tf([1], [1, 1, 0])

    plt.figure(figsize=(16, 12))

    for i, K in enumerate(Kvalues):
        Hloop = K * Hplant

        w = np.logspace(-2, 2, 1000)
        mag, phase, omega = ct.bodeplot(Hloop, w, plot=False)

        # Calculate margins
        gm, pm, wg, wp = ct.margin(Hloop)

        # Magnitude plot
        plt.subplot(2, 2, 1)
        magdb = 20*np.log10(mag)
        plt.semilogx(omega, magdb, linewidth=2, label=f'K={K}, GM={20*np.log10(gm):.1f}dB')

        if i == 0:  # Add reference lines only once
            plt.axhline(y=0, color='k', linestyle='--', alpha=0.5, label='0 dB')

        # Phase plot
        plt.subplot(2, 2, 2)
        phasedeg = np.degrees(phase)
        plt.semilogx(omega, phasedeg, linewidth=2, label=f'K={K}, PM={np.degrees(pm):.1f}°')

        if i == 0:  # Add reference lines only once
            plt.axhline(y=-180, color='k', linestyle='--', alpha=0.5, label='-180°')

    plt.subplot(2, 2, 1)
    plt.title('Gain Margin Analysis')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)
    plt.legend()

    plt.subplot(2, 2, 2)
    plt.title('Phase Margin Analysis')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Phase [degrees]')
    plt.grid(True)
    plt.legend()

    # Stability analysis
    plt.subplot(2, 1, 2)
    Krange = np.logspace(-1, 1, 50)
    gmvalues = []
    pmvalues = []

    for K in Krange:
        Hloop = K * Hplant
        try:
            gm, pm, wg, wp = ct.margin(Hloop)
            gmvalues.append(20*np.log10(gm))
            pmvalues.append(np.degrees(pm))
        except:
            gmvalues.append(np.nan)
            pmvalues.append(np.nan)

    plt.subplot(2, 1, 2)
    plt.semilogx(Krange, gmvalues, 'b-', linewidth=2, label='Gain Margin [dB]')
    plt.semilogx(Krange, pmvalues, 'r-', linewidth=2, label='Phase Margin [°]')
    plt.axhline(y=0, color='k', linestyle='--', alpha=0.5)
    plt.axhline(y=45, color='g', linestyle=':', alpha=0.5, label='Good PM (45°)')
    plt.axhline(y=6, color='g', linestyle=':', alpha=0.5, label='Good GM (6dB)')

    plt.title('Stability Margins vs Controller Gain')
    plt.xlabel('Controller Gain K')
    plt.ylabel('Margin Value')
    plt.grid(True)
    plt.legend()

    plt.tightlayout()
    plt.show()

stabilitymargins()
```

[@tbl:frequency-parameters] merangkum parameter kinerja domain frekuensi yang umum digunakan.

| Parameter         | Definisi           | Signifikansi            | Nilai Tipikal              |
| ----------------- | ------------------ | ----------------------- | -------------------------- |
| Bandwidth       | Frekuensi -3dB     | Kecepatan respons       | Lebih tinggi = lebih cepat |
| Resonant Peak   | Magnitude maksimum | Stabilitas relatif      | < 6 dB untuk sistem baik   |
| Gain Margin     | Margin penguatan   | Robustness              | > 6 dB                     |
| Phase Margin    | Margin fase        | Stabilitas              | > 45°                      |
| Gain Crossover  | Frekuensi 0 dB     | Bandwidth closed-loop | -                          |
| Phase Crossover | Frekuensi -180°    | Titik ketidakstabilan   | -                          |

: Parameter Kinerja Domain Frekuensi {#tbl:frequency-parameters}

## Bode Plot

Bode plot adalah representasi grafis yang paling umum digunakan untuk analisis respons frekuensi. Plot ini terdiri dari dua grafik: magnitude (dalam dB) dan fase (dalam derajat) sebagai fungsi frekuensi (dalam skala logaritmik).

### Konsep dan Interpretasi

Bode plot memberikan visualisasi yang intuitif tentang bagaimana sistem berperilaku pada berbagai frekuensi. Keunggulan utama Bode plot adalah kemudahan dalam:

1. Analisis Stabilitas: Margin kestabilan dapat langsung dibaca dari plot
2. Desain Kontroler: Kompensator dapat dirancang secara grafis
3. Analisis Komposit: Respons sistem kompleks dapat dianalisis dengan menjumlahkan kontribusi setiap komponen

```python
def bodeplotanalysis():
    # Different system types
    systems = {
        'Integrator': ct.tf([1], [1, 0]),
        'First Order': ct.tf([1], [1, 1]),
        'Second Order (ζ=0.1)': ct.tf([1], [1, 0.2, 1]),
        'Second Order (ζ=0.7)': ct.tf([1], [1, 1.4, 1]),
        'Lead Compensator': ct.tf([1, 1], [0.1, 1]),
        'Lag Compensator': ct.tf([0.1, 1], [1, 1])
    }

    w = np.logspace(-2, 2, 1000)

    plt.figure(figsize=(18, 14))

    # Individual Bode plots
    for i, (name, H) in enumerate(systems.items(), 1):
        plt.subplot(3, 4, i)
        ct.bodeplot(H, w, plot=True)
        plt.title(f'{name}')

        if i <= 2:  # Only for first row
            plt.xlabel('')

    # Combined magnitude plot
    plt.subplot(3, 2, 5)
    for name, H in systems.items():
        mag, phase, omega = ct.bodeplot(H, w, plot=False)
        plt.semilogx(omega, 20*np.log10(mag), linewidth=2, label=name)

    plt.title('Combined Magnitude Responses')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)
    plt.legend()

    # Combined phase plot
    plt.subplot(3, 2, 6)
    for name, H in systems.items():
        mag, phase, omega = ct.bodeplot(H, w, plot=False)
        plt.semilogx(omega, np.degrees(phase), linewidth=2, label=name)

    plt.title('Combined Phase Responses')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Phase [degrees]')
    plt.grid(True)
    plt.legend()

    plt.tightlayout()
    plt.show()

bodeplotanalysis()
```

### Asymptotic Approximation

Salah satu kekuatan Bode plot adalah kemampuan untuk membuat aproksimasi asimptotik yang memudahkan analisis manual.

```python
def asymptoticbode():
    # System with multiple poles and zeros
    H = ct.tf([10, 100], [1, 11, 110, 1000])

    # Factor the transfer function
    poles = ct.pole(H)
    zeros = ct.zero(H)

    print("System poles:", poles)
    print("System zeros:", zeros)

    w = np.logspace(-1, 3, 1000)
    mag, phase, omega = ct.bodeplot(H, w, plot=False)

    plt.figure(figsize=(14, 10))

    # Exact magnitude response
    plt.subplot(2, 1, 1)
    plt.semilogx(omega, 20*np.log10(mag), 'b-', linewidth=2, label='Exact')

    # Asymptotic approximation
    magasymptotic = np.oneslike(omega) * 20*np.log10(10)  # DC gain

    # Add pole contributions
    for pole in poles:
        if np.real(pole) < 0:  # Stable pole
            polefreq = abs(pole)
            for i, wval in enumerate(omega):
                if wval > polefreq:
                    magasymptotic[i] -= 20*np.log10(wval/polefreq)

    # Add zero contributions
    for zero in zeros:
        if np.real(zero) < 0:  # Minimum phase zero
            zerofreq = abs(zero)
            for i, wval in enumerate(omega):
                if wval > zerofreq:
                    magasymptotic[i] += 20*np.log10(wval/zerofreq)

    plt.semilogx(omega, magasymptotic, 'r--', linewidth=2, label='Asymptotic')

    # Mark corner frequencies
    for pole in poles:
        if np.real(pole) < 0:
            plt.axvline(x=abs(pole), color='k', linestyle=':', alpha=0.5)
    for zero in zeros:
        if np.real(zero) < 0:
            plt.axvline(x=abs(zero), color='g', linestyle=':', alpha=0.5)

    plt.title('Asymptotic vs Exact Bode Plot')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)
    plt.legend()

    # Phase response
    plt.subplot(2, 1, 2)
    plt.semilogx(omega, np.degrees(phase), 'b-', linewidth=2, label='Exact Phase')

    # Asymptotic phase
    phaseasymptotic = np.zeroslike(omega)
    for pole in poles:
        if np.real(pole) < 0:
            polefreq = abs(pole)
            for i, wval in enumerate(omega):
                if wval > polefreq * 0.1:
                    if wval < polefreq * 10:
                        phaseasymptotic[i] -= 45 * (np.log10(wval) - np.log10(polefreq * 0.1))
                    else:
                        phaseasymptotic[i] -= 90

    plt.semilogx(omega, phaseasymptotic, 'r--', linewidth=2, label='Asymptotic Phase')
    plt.title('Phase Response')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Phase [degrees]')
    plt.grid(True)
    plt.legend()

    plt.tightlayout()
    plt.show()

asymptoticbode()
```

### Cara Membaca Bode Plot

```python
def bodereadingguide():
    H = ct.tf([100], [1, 12, 100])

    w = np.logspace(-1, 2, 1000)
    mag, phase, omega = ct.bodeplot(H, w, plot=False)

    plt.figure(figsize=(14, 10))

    # Magnitude analysis
    plt.subplot(2, 1, 1)
    magdb = 20*np.log10(mag)
    plt.semilogx(omega, magdb, 'b-', linewidth=3)

    # Key points annotation
    dcgain = magdb[0]
    plt.axhline(y=dcgain, color='g', linestyle='--', alpha=0.7, label=f'DC Gain: {dcgain:.1f} dB')
    plt.axhline(y=dcgain-3, color='r', linestyle='--', alpha=0.7, label='-3dB line')

    # Find -3dB frequency
    cutoffidx = np.where(magdb <= dcgain-3)[0]
    if len(cutoffidx) > 0:
        cutofffreq = omega[cutoffidx[0]]
        plt.axvline(x=cutofffreq, color='r', linestyle='--', alpha=0.7,
                   label=f'Bandwidth: {cutofffreq:.1f} rad/s')

    # Find resonant peak
    peakidx = np.argmax(magdb)
    peakfreq = omega[peakidx]
    peakmag = magdb[peakidx]
    plt.plot(peakfreq, peakmag, 'ro', markersize=8,
             label=f'Resonant Peak: {peakmag:.1f} dB')

    plt.title('Magnitude Plot Reading Guide')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)
    plt.legend()

    # Phase analysis
    plt.subplot(2, 1, 2)
    phasedeg = np.degrees(phase)
    plt.semilogx(omega, phasedeg, 'b-', linewidth=3)

    # Key phase points
    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3, label='0°')
    plt.axhline(y=-90, color='g', linestyle='--', alpha=0.7, label='-90°')
    plt.axhline(y=-180, color='r', linestyle='--', alpha=0.7, label='-180°')

    # Find phase at bandwidth frequency
    if len(cutoffidx) > 0:
        phaseatcutoff = phasedeg[cutoffidx[0]]
        plt.plot(cutofffreq, phaseatcutoff, 'ro', markersize=8,
                label=f'Phase at BW: {phaseatcutoff:.1f}°')

    plt.title('Phase Plot Reading Guide')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Phase [degrees]')
    plt.grid(True)
    plt.legend()

    plt.tightlayout()
    plt.show()

bodereadingguide()
```

## Nyquist Plot

Nyquist plot adalah representasi polar dari respons frekuensi yang sangat powerful untuk analisis stabilitas. Plot ini menampilkan locus dari $H(j\omega)$ pada bidang kompleks untuk $\omega$ dari $-\infty$ hingga $+\infty$.

### Konsep dan Interpretasi

Nyquist plot memberikan informasi yang sama dengan Bode plot tetapi dalam format yang memudahkan aplikasi kriteria stabilitas Nyquist. Keunggulan utama adalah kemampuan untuk menentukan stabilitas sistem closed-loop berdasarkan plot sistem open-loop.

```python
def nyquistanalysis():
    systems = {
        'Stable System': ct.tf([1], [1, 2, 1]),
        'Marginally Stable': ct.tf([1], [1, 1, 1]),
        'Unstable Open-Loop': ct.tf([1], [1, -1, 1]),
        'High Gain': ct.tf([10], [1, 1, 1])
    }

    plt.figure(figsize=(16, 12))

    for i, (name, H) in enumerate(systems.items(), 1):
        plt.subplot(2, 2, i)

        # Generate Nyquist plot
        w = np.logspace(-2, 2, 1000)
        nyquistresponse = []

        for freq in w:
            Hval = ct.evalfr(H, 1j*freq)
            nyquistresponse.append(Hval)

        nyquistresponse = np.array(nyquistresponse)

        # Plot positive frequencies
        plt.plot(np.real(nyquistresponse), np.imag(nyquistresponse),
                'b-', linewidth=2, label='ω > 0')

        # Plot negative frequencies (complex conjugate)
        plt.plot(np.real(nyquistresponse), -np.imag(nyquistresponse),
                'r--', linewidth=2, label='ω < 0')

        # Mark critical point
        plt.plot(-1, 0, 'ro', markersize=8, label='Critical Point (-1,0)')

        # Mark low and high frequency points
        plt.plot(np.real(nyquistresponse[0]), np.imag(nyquistresponse[0]),
                'go', markersize=6, label='ω → 0')
        plt.plot(np.real(nyquistresponse[-1]), np.imag(nyquistresponse[-1]),
                'mo', markersize=6, label='ω → ∞')

        plt.title(f'{name}')
        plt.xlabel('Real Part')
        plt.ylabel('Imaginary Part')
        plt.grid(True)
        plt.axis('equal')
        plt.legend()

        # Add stability analysis
        # Simple check for encirclement of -1 point
        distances = np.abs(nyquistresponse + 1)
        mindistance = np.min(distances)

        plt.text(0.02, 0.98, f'Min dist to (-1,0): {mindistance:.2f}',
                transform=plt.gca().transAxes, verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='wheat'))

    plt.tightlayout()
    plt.show()

nyquistanalysis()
```

### Kriteria Stabilitas Nyquist

Kriteria stabilitas Nyquist menyatakan bahwa sistem closed-loop stabil jika dan hanya jika Nyquist plot dari sistem open-loop mengelilingi titik (-1,0) sebanyak $P$ kali berlawanan arah jarum jam, dimana $P$ adalah jumlah poles open-loop yang tidak stabil.

```python
def nyquiststabilitycriterion():
    # Example: varying controller gain
    Kvalues = [0.5, 1, 2, 5, 10]
    Hplant = ct.tf([1], [1, 1, 0])

    plt.figure(figsize=(15, 10))

    plt.subplot(2, 2, 1)
    for K in Kvalues:
        Hloop = K * Hplant

        w = np.logspace(-2, 2, 500)
        nyquistresponse = []

        for freq in w:
            try:
                Hval = ct.evalfr(Hloop, 1j*freq)
                nyquistresponse.append(Hval)
            except:
                nyquistresponse.append(np.nan + 1j*np.nan)

        nyquistresponse = np.array(nyquistresponse)
        validindices = ~np.isnan(nyquistresponse)

        if np.any(validindices):
            plt.plot(np.real(nyquistresponse[validindices]),
                    np.imag(nyquistresponse[validindices]),
                    linewidth=2, label=f'K = {K}')

    plt.plot(-1, 0, 'ro', markersize=10, label='Critical Point')
    plt.xlabel('Real Part')
    plt.ylabel('Imaginary Part')
    plt.title('Nyquist Plot for Different Gains')
    plt.grid(True)
    plt.legend()
    plt.axis('equal')

    # Stability margins from Nyquist plot
    plt.subplot(2, 2, 2)
    K = 2  # Example gain
    Hloop = K * Hplant

    w = np.logspace(-2, 2, 1000)
    gm, pm, wg, wp = ct.margin(Hloop)

    # Plot for margin illustration
    nyquistresponse = []
    for freq in w:
        try:
            Hval = ct.evalfr(Hloop, 1j*freq)
            nyquistresponse.append(Hval)
        except:
            nyquistresponse.append(np.nan + 1j*np.nan)

    nyquistresponse = np.array(nyquistresponse)
    validindices = ~np.isnan(nyquistresponse)

    plt.plot(np.real(nyquistresponse[validindices]),
            np.imag(nyquistresponse[validindices]),
            'b-', linewidth=2, label='Nyquist Plot')

    # Mark gain and phase margins
    plt.plot(-1, 0, 'ro', markersize=10, label='Critical Point')

    # Gain crossover point (|H(jωg)| = 1)
    gcpoint = ct.evalfr(Hloop, 1j*wg)
    plt.plot(np.real(gcpoint), np.imag(gcpoint), 'go', markersize=8,
             label=f'Gain Crossover (ωg = {wg:.2f})')

    # Phase crossover point (∠H(jωp) = -180°)
    if wp is not None and wp > 0:
        pcpoint = ct.evalfr(Hloop, 1j*wp)
        plt.plot(np.real(pcpoint), np.imag(pcpoint), 'mo', markersize=8,
                 label=f'Phase Crossover (ωp = {wp:.2f})')

    plt.xlabel('Real Part')
    plt.ylabel('Imaginary Part')
    plt.title(f'Stability Margins (K = {K})')
    plt.grid(True)
    plt.legend()
    plt.axis('equal')

    # Gain and phase margin visualization
    plt.subplot(2, 1, 2)
    Krange = np.logspace(-1, 1.5, 50)
    gmvalues = []
    pmvalues = []
    stableflags = []

    for Ktest in Krange:
        Htest = Ktest * Hplant
        try:
            gmtemp, pmtemp, wgtemp, wptemp = ct.margin(Htest)
            gmvalues.append(20*np.log10(gmtemp) if gmtemp > 0 else -np.inf)
            pmvalues.append(np.degrees(pmtemp) if pmtemp > 0 else -180)

            # Check stability
            polescl = ct.pole(ct.feedback(Htest, 1))
            stable = all(np.real(polescl) < 0)
            stableflags.append(stable)
        except:
            gmvalues.append(np.nan)
            pmvalues.append(np.nan)
            stableflags.append(False)

    # Color-code stability
    stableK = [Krange[i] for i, stable in enumerate(stableflags) if stable]
    stableGM = [gmvalues[i] for i, stable in enumerate(stableflags) if stable]
    stablePM = [pmvalues[i] for i, stable in enumerate(stableflags) if stable]

    unstableK = [Krange[i] for i, stable in enumerate(stableflags) if not stable]
    unstableGM = [gmvalues[i] for i, stable in enumerate(stableflags) if not stable]
    unstablePM = [pmvalues[i] for i, stable in enumerate(stableflags) if not stable]

    if stableK:
        plt.semilogx(stableK, stableGM, 'g-', linewidth=2, label='GM (Stable)')
        plt.semilogx(stableK, stablePM, 'b-', linewidth=2, label='PM (Stable)')

    if unstableK:
        plt.semilogx(unstableK, unstableGM, 'r--', linewidth=2, label='GM (Unstable)')
        plt.semilogx(unstableK, unstablePM, 'r--', linewidth=2, label='PM (Unstable)')

    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    plt.axhline(y=45, color='g', linestyle=':', alpha=0.5, label='Desired PM (45°)')
    plt.axhline(y=6, color='g', linestyle=':', alpha=0.5, label='Desired GM (6dB)')

    plt.title('Stability Analysis vs Controller Gain')
    plt.xlabel('Controller Gain K')
    plt.ylabel('Margin [dB or degrees]')
    plt.grid(True)
    plt.legend()

    plt.tightlayout()
    plt.show()

nyquiststabilitycriterion()
```

### Aplikasi untuk Analisis Stabilitas

```python
def nyquiststabilityexamples():
    # Different stability cases
    cases = {
        'Stable': {
            'system': ct.tf([1], [1, 3, 2]),
            'description': 'All poles in LHP, no encirclement needed'
        },
        'Conditionally Stable': {
            'system': ct.tf([1, 1], [1, 1, 0, 0]),
            'description': 'Two poles at origin, needs careful analysis'
        },
        'Unstable Plant': {
            'system': ct.tf([1], [1, -1, 2]),
            'description': 'One pole in RHP, needs one encirclement'
        }
    }

    plt.figure(figsize=(18, 6))

    for i, (name, case) in enumerate(cases.items(), 1):
        plt.subplot(1, 3, i)

        H = case['system']
        w = np.logspace(-2, 2, 1000)

        # Calculate Nyquist response
        nyquistresponse = []
        for freq in w:
            try:
                Hval = ct.evalfr(H, 1j*freq)
                if not np.isnan(Hval) and not np.isinf(Hval):
                    nyquistresponse.append(Hval)
                else:
                    nyquistresponse.append(None)
            except:
                nyquistresponse.append(None)

        # Filter out None values
        validresponse = [r for r in nyquistresponse if r is not None]
        validresponse = np.array(validresponse)

        if len(validresponse) > 0:
            plt.plot(np.real(validresponse), np.imag(validresponse),
                    'b-', linewidth=2, label='Nyquist Plot')
            plt.plot(np.real(validresponse), -np.imag(validresponse),
                    'r--', linewidth=1, label='Mirror (ω < 0)')

        plt.plot(-1, 0, 'ro', markersize=10, label='Critical Point (-1,0)')

        plt.title(f'{name}')
        plt.xlabel('Real Part')
        plt.ylabel('Imaginary Part')
        plt.grid(True)
        plt.legend()
        plt.axis('equal')

        # Add description
        plt.text(0.02, 0.02, case['description'],
                transform=plt.gca().transAxes,
                verticalalignment='bottom',
                bbox=dict(boxstyle='round', facecolor='lightyellow'))

    plt.tightlayout()
    plt.show()

nyquiststabilityexamples()
```

## Nichols Chart

Nichols chart menggabungkan informasi magnitude dan fase dalam satu plot dengan sumbu fase (horizontal) dan magnitude dalam dB (vertikal). Chart ini sangat berguna untuk desain kontroler karena memungkinkan visualisasi simultan dari spesifikasi closed-loop.

### Konsep dan Penggunaan

Nichols chart memiliki grid kontur yang menunjukkan magnitude dan fase closed-loop konstan. Ini memungkinkan insinyur untuk melihat bagaimana perubahan pada kontroler mempengaruhi performa closed-loop.

```python
def nicholschartanalysis():
    # System examples
    H1 = ct.tf([1], [1, 1, 1])
    H2 = ct.tf([10], [1, 1, 1])
    H3 = ct.tf([1], [1, 0.2, 1])

    systems = [H1, H2, H3]
    names = ['Low Gain', 'High Gain', 'Low Damping']

    plt.figure(figsize=(16, 12))

    # Individual Nichols plots
    for i, (H, name) in enumerate(zip(systems, names)):
        plt.subplot(2, 2, i+1)

        w = np.logspace(-2, 2, 1000)
        mag, phase, omega = ct.bodeplot(H, w, plot=False)

        # Convert to dB and degrees
        magdb = 20*np.log10(mag)
        phasedeg = np.degrees(phase)

        # Wrap phase to [-180, 180]
        phasewrapped = np.mod(phasedeg + 180, 360) - 180

        plt.plot(phasewrapped, magdb, 'b-', linewidth=2, label=name)

        # Mark frequency points
        freqpoints = [0.1, 1, 10]
        for freq in freqpoints:
            if freq >= omega[0] and freq <= omega[-1]:
                idx = np.argmin(np.abs(omega - freq))
                plt.plot(phasewrapped[idx], magdb[idx], 'ro', markersize=6)
                plt.annotate(f'{freq} rad/s',
                           (phasewrapped[idx], magdb[idx]),
                           xytext=(10, 10), textcoords='offset points')

        plt.xlabel('Phase [degrees]')
        plt.ylabel('Magnitude [dB]')
        plt.title(f'{name} - Nichols Plot')
        plt.grid(True)
        plt.axhline(y=0, color='k', linestyle='--', alpha=0.5)
        plt.axvline(x=-180, color='k', linestyle='--', alpha=0.5)

    # Combined plot with M-circles and N-circles
    plt.subplot(2, 2, 4)

    for H, name in zip(systems, names):
        w = np.logspace(-2, 2, 1000)
        mag, phase, omega = ct.bodeplot(H, w, plot=False)

        magdb = 20*np.log10(mag)
        phasedeg = np.degrees(phase)
        phasewrapped = np.mod(phasedeg + 180, 360) - 180

        plt.plot(phasewrapped, magdb, linewidth=2, label=name)

    # Add M-circles (constant closed-loop magnitude)
    Mvalues = [0, 3, 6, 12]  # dB
    phaserange = np.linspace(-180, 0, 1000)

    for Mdb in Mvalues:
        Mlinear = 10(Mdb/20)
        if Mdb == 0:
            continue  # Skip 0 dB (would be infinite)

        # Calculate magnitude for M-circle
        magM = []
        for phi in phaserange:
            phirad = np.radians(phi)
            # Formula for M-circle in Nichols chart
            if Mlinear != 1:
                magval = 20*np.log10(Mlinear/np.abs(1 + Mlinear*np.exp(1j*phirad)))
                magM.append(magval)
            else:
                magM.append(np.inf)

        if len(magM) > 0 and not all(np.isinf(magM)):
            plt.plot(phaserange, magM, 'k--', alpha=0.5, linewidth=1)
            # Label the M-circle
            mididx = len(magM) // 2
            if not np.isinf(magM[mididx]):
                plt.annotate(f'M={Mdb}dB',
                           (phaserange[mididx], magM[mididx]),
                           fontsize=8, alpha=0.7)

    plt.xlabel('Phase [degrees]')
    plt.ylabel('Magnitude [dB]')
    plt.title('Combined Nichols Plot with M-circles')
    plt.grid(True)
    plt.legend()
    plt.xlim([-180, 0])

    plt.tightlayout()
    plt.show()

nicholschartanalysis()
```

### Aplikasi dalam Desain Kontroler

```python
def nicholsdesignexample():
    # Plant transfer function
    G = ct.tf([1], [1, 1, 0])

    # Different controller designs
    controllers = {
        'P': ct.tf([2], [1]),
        'PI': ct.tf([2, 1], [1, 0]),
        'PD': ct.tf([2, 2], [1]),
        'PID': ct.tf([2, 3, 1], [1, 0])
    }

    plt.figure(figsize=(16, 12))

    # Nichols plots for different controllers
    for i, (ctrlname, C) in enumerate(controllers.items(), 1):
        plt.subplot(2, 2, i)

        # Open-loop transfer function
        L = ct.series(C, G)

        w = np.logspace(-2, 2, 1000)
        mag, phase, omega = ct.bodeplot(L, w, plot=False)

        magdb = 20*np.log10(mag)
        phasedeg = np.degrees(phase)
        phasewrapped = np.mod(phasedeg + 180, 360) - 180

        plt.plot(phasewrapped, magdb, 'b-', linewidth=2, label=f'{ctrlname} Controller')

        # Calculate closed-loop system
        T = ct.feedback(L, 1)

        # Check stability
        polescl = ct.pole(T)
        stable = all(np.real(polescl) < 0)

        # Calculate margins
        try:
            gm, pm, wg, wp = ct.margin(L)
            gmdb = 20*np.log10(gm)
            pmdeg = np.degrees(pm)
        except:
            gmdb = np.inf
            pmdeg = np.inf

        # Mark critical points
        plt.axhline(y=0, color='k', linestyle='--', alpha=0.5, label='0 dB')
        plt.axvline(x=-180, color='k', linestyle='--', alpha=0.5, label='-180°')

        # Add performance info
        infotext = f"Stable: {'Yes' if stable else 'No'}\n"
        infotext += f"GM: {gmdb:.1f} dB\n"
        infotext += f"PM: {pmdeg:.1f}°"

        plt.text(0.02, 0.98, infotext, transform=plt.gca().transAxes,
                verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='lightblue'))

        plt.xlabel('Phase [degrees]')
        plt.ylabel('Magnitude [dB]')
        plt.title(f'{ctrlname} Controller')
        plt.grid(True)
        plt.legend()
        plt.xlim([-270, -90])
        plt.ylim([-40, 40])

    plt.tightlayout()
    plt.show()

    # Performance comparison
    plt.figure(figsize=(14, 8))

    # Step responses
    plt.subplot(1, 2, 1)
    for ctrlname, C in controllers.items():
        L = ct.series(C, G)
        T = ct.feedback(L, 1)

        try:
            t, y = ct.stepresponse(T)
            plt.plot(t, y, linewidth=2, label=f'{ctrlname}')
        except:
            print(f"Warning: Could not compute step response for {ctrlname}")

    plt.title('Closed-Loop Step Responses')
    plt.xlabel('Time [s]')
    plt.ylabel('Output')
    plt.grid(True)
    plt.legend()

    # Frequency responses
    plt.subplot(1, 2, 2)
    w = np.logspace(-2, 2, 1000)

    for ctrlname, C in controllers.items():
        L = ct.series(C, G)
        T = ct.feedback(L, 1)

        try:
            mag, phase, omega = ct.bodeplot(T, w, plot=False)
            plt.semilogx(omega, 20*np.log10(mag), linewidth=2, label=f'{ctrlname}')
        except:
            print(f"Warning: Could not compute frequency response for {ctrlname}")

    plt.title('Closed-Loop Frequency Responses')
    plt.xlabel('Frequency [rad/s]')
    plt.ylabel('Magnitude [dB]')
    plt.grid(True)
    plt.legend()
    plt.axhline(y=-3, color='k', linestyle='--', alpha=0.5, label='-3dB')

    plt.tightlayout()
    plt.show()

nicholsdesignexample()
```

[@tbl:frequency-tools] merangkum perbandingan alat analisis domain frekuensi yang telah dibahas.

| Alat Analisis   | Keunggulan                        | Aplikasi Utama                  | Informasi yang Diperoleh               |
| --------------- | --------------------------------- | ------------------------------- | -------------------------------------- |
| Bode Plot     | Mudah dibaca, analisis asimptotik | Analisis umum, desain kontroler | Magnitude, fase, bandwidth, margin     |
| Nyquist Plot  | Analisis stabilitas langsung      | Kriteria stabilitas Nyquist     | Stabilitas, margin, robustness         |
| Nichols Chart | Spesifikasi closed-loop         | Desain kontroler, optimasi      | Performance closed-loop, sensitivity |

: Perbandingan Alat Analisis Domain Frekuensi {#tbl:frequency-tools}

Dengan pemahaman komprehensif tentang analisis domain frekuensi ini, pembaca memiliki fondasi yang kuat untuk melakukan analisis stabilitas dan desain kontroler. Konsep-konsep yang telah dipelajari akan menjadi dasar untuk topik lanjutan seperti analisis kestabilan sistem dan desain kontroler PID pada bab-bab berikutnya. Kemampuan untuk beralih antara representasi domain waktu dan frekuensi merupakan keterampilan essential dalam engineering sistem kendali modern.

