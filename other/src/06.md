# Analisis Kestabilan Sistem

Kestabilan merupakan aspek fundamental dalam analisis dan desain sistem kendali. Sistem yang tidak stabil akan menghasilkan respons yang divergen dan tidak dapat digunakan dalam aplikasi praktis. Bab ini membahas konsep kestabilan sistem dinamis, metode analisis pole-zero, kriteria kestabilan Routh-Hurwitz, dan analisis kinerja error sistem.

## Konsep Kestabilan Sistem Dinamis

Kestabilan (stability) dalam sistem kendali didefinisikan sebagai kemampuan sistem untuk kembali ke kondisi kesetimbangan setelah mengalami gangguan kecil. Definisi matematis kestabilan didasarkan pada perilaku variabel keadaan sistem terhadap waktu.

### Definisi Matematis Kestabilan

Sistem linier waktu-invarian (LTI) dengan persamaan karakteristik:

$$
s^n + a_{n-1}s^{n-1} + ... + a_1s + a_0 = 0
$$

Sistem dinyatakan stabil jika semua pole (akar persamaan karakteristik) memiliki bagian real negatif. Secara matematis:

$$
Re(s_i) < 0, untuk semua i = 1, 2, ..., n
$$

### Tipe-Tipe Kestabilan

Terdapat beberapa tipe kestabilan dalam sistem dinamis:

| Tipe Kestabilan  | Definisi                       | Lokasi Pole         |
| ---------------- | ------------------------------ | ------------------- |
| Stabil Asimtotik | Respons menuju nol untuk t → ∞ | Bagian real negatif |
| Stabil Marginal  | Respons tetap terbatas         | Pada sumbu imajiner |
| Tidak Stabil     | Respons divergen               | Bagian real positif |

<!-- Gambar 6.1: Diagram letak pole pada bidang-s untuk berbagai kondisi kestabilan -->

### Pentingnya Kestabilan dalam Sistem Kendali

Kestabilan menjadi syarat mutlak dalam desain sistem kendali karena:

1. Keamanan Operasi: Sistem yang tidak stabil dapat menyebabkan kerusakan peralatan atau bahaya keselamatan
2. Performa Sistem: Hanya sistem stabil yang dapat memberikan respons yang dapat diprediksi
3. Robustnes: Sistem stabil memiliki toleransi terhadap gangguan dan ketidakpastian parameter

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import control

# Contoh analisis kestabilan sistem berbeda
def analyze_stability_examples():
    # Sistem stabil: poles di sisi kiri bidang-s
    num1 = [1]
    den1 = [1, 3, 2]  # s^2 + 3s + 2 = (s+1)(s+2)
    sys1 = signal.TransferFunction(num1, den1)

    # Sistem tidak stabil: pole di sisi kanan bidang-s
    num2 = [1]
    den2 = [1, -1, 2]  # s^2 - s + 2
    sys2 = signal.TransferFunction(num2, den2)

    # Sistem marginal stabil: pole pada sumbu imajiner
    num3 = [1]
    den3 = [1, 0, 1]  # s^2 + 1
    sys3 = signal.TransferFunction(num3, den3)

    # Hitung poles
    poles1 = np.roots(den1)
    poles2 = np.roots(den2)
    poles3 = np.roots(den3)

    print("Analisis Pole dan Kestabilan:")
    print(f"Sistem 1 - Poles: {poles1}")
    print(f"Real parts: {np.real(poles1)} - Stabil: {np.all(np.real(poles1) < 0)}")

    print(f"\nSistem 2 - Poles: {poles2}")
    print(f"Real parts: {np.real(poles2)} - Stabil: {np.all(np.real(poles2) < 0)}")

    print(f"\nSistem 3 - Poles: {poles3}")
    print(f"Real parts: {np.real(poles3)} - Marginal stabil: {np.all(np.real(poles3) == 0)}")

    return sys1, sys2, sys3, poles1, poles2, poles3

# Visualisasi respons step untuk sistem dengan kestabilan berbeda
def plot_step_responses():
    sys1, sys2, sys3, _, _, _ = analyze_stability_examples()

    t = np.linspace(0, 10, 1000)

    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 5))

    # Respons sistem stabil
    _, y1 = signal.step(sys1, T=t)
    ax1.plot(t, y1)
    ax1.set_title('Sistem Stabil')
    ax1.set_xlabel('Waktu (s)')
    ax1.set_ylabel('Amplitude')
    ax1.grid(True)

    # Respons sistem tidak stabil
    _, y2 = signal.step(sys2, T=t)
    ax2.plot(t, y2)
    ax2.set_title('Sistem Tidak Stabil')
    ax2.set_xlabel('Waktu (s)')
    ax2.set_ylabel('Amplitude')
    ax2.grid(True)

    # Respons sistem marginal stabil
    _, y3 = signal.step(sys3, T=t)
    ax3.plot(t, y3)
    ax3.set_title('Sistem Marginal Stabil')
    ax3.set_xlabel('Waktu (s)')
    ax3.set_ylabel('Amplitude')
    ax3.grid(True)

    plt.tight_layout()
    plt.show()

analyze_stability_examples()
plot_step_responses()
```

Kode di atas mendemonstrasikan tiga kondisi kestabilan berbeda dengan menganalisis letak pole dan respons step sistem. Sistem stabil menunjukkan respons yang konvergen, sistem tidak stabil menunjukkan respons divergen, dan sistem marginal stabil menunjukkan osilasi berkelanjutan.

## Analisis Pole dan Zero Sistem

Pole dan zero merupakan karakteristik fundamental fungsi transfer yang menentukan perilaku dinamis sistem. Analisis pole-zero memberikan wawasan mendalam tentang stabilitas dan respons sistem tanpa perlu simulasi eksplisit.

### Definisi dan Interpretasi Pole-Zero

Pole adalah nilai s yang membuat denominator fungsi transfer sama dengan nol, sedangkan zero adalah nilai s yang membuat numerator sama dengan nol. Untuk fungsi transfer:

$$
G(s) = N(s)/D(s) = K(s - z₁)(s - z₂)...(s - zₘ) / (s - p₁)(s - p₂)...(s - pₙ)
$$

Di mana:

- p₁, p₂, ..., pₙ adalah pole sistem
- z₁, z₂, ..., zₘ adalah zero sistem
- K adalah gain konstanta

#### Interpretasi Fisik Pole dan Zero

1. Pole: Menentukan mode natural sistem dan karakteristik respons

   - Pole real negatif: Mode eksponensial yang meluruh
   - Pole kompleks konjugat: Mode osilasi yang teredam
   - Pole pada sumbu imajiner: Osilasi berkelanjutan

2. Zero: Mempengaruhi magnitude dan fase respons pada frekuensi tertentu
   - Zero dapat mengurangi atau menghilangkan mode tertentu
   - Zero pada bidang kanan (RHP zero) menyebabkan respons undershoot

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import control

def analyze_pole_zero_effects():
    # Sistem dengan berbagai konfigurasi pole-zero
    systems = []

    # Sistem 1: Hanya pole (tanpa zero)
    num1 = [1]
    den1 = [1, 3, 2]  # (s+1)(s+2)
    sys1 = signal.TransferFunction(num1, den1)
    systems.append(('Tanpa Zero', sys1))

    # Sistem 2: Dengan zero di sebelah kiri
    num2 = [1, 0.5]  # (s+0.5)
    den2 = [1, 3, 2]
    sys2 = signal.TransferFunction(num2, den2)
    systems.append(('Zero Kiri', sys2))

    # Sistem 3: Dengan zero di sebelah kanan (RHP zero)
    num3 = [1, -0.5]  # (s-0.5)
    den3 = [1, 3, 2]
    sys3 = signal.TransferFunction(num3, den3)
    systems.append(('RHP Zero', sys3))

    # Plot pole-zero map
    fig, axes = plt.subplots(2, 3, figsize=(15, 10))

    for i, (name, sys) in enumerate(systems):
        # Pole-zero plot
        poles = np.roots(sys.den)
        zeros = np.roots(sys.num) if len(sys.num) > 1 else []

        axes[0, i].scatter(np.real(poles), np.imag(poles),
                          marker='x', s=100, c='red', label='Poles')
        if len(zeros) > 0:
            axes[0, i].scatter(np.real(zeros), np.imag(zeros),
                              marker='o', s=100, c='blue', label='Zeros')

        axes[0, i].axhline(y=0, color='k', linestyle='-', alpha=0.3)
        axes[0, i].axvline(x=0, color='k', linestyle='-', alpha=0.3)
        axes[0, i].grid(True)
        axes[0, i].set_title(f'Pole-Zero Map: {name}')
        axes[0, i].set_xlabel('Real Part')
        axes[0, i].set_ylabel('Imaginary Part')
        axes[0, i].legend()

        # Step response
        t = np.linspace(0, 5, 1000)
        _, y = signal.step(sys, T=t)
        axes[1, i].plot(t, y)
        axes[1, i].set_title(f'Step Response: {name}')
        axes[1, i].set_xlabel('Time (s)')
        axes[1, i].set_ylabel('Amplitude')
        axes[1, i].grid(True)

    plt.tight_layout()
    plt.show()

    return systems

# Analisis numerik pole dan zero
def numerical_pole_zero_analysis():
    # Contoh sistem orde tinggi
    num = [1, 2, 1]
    den = [1, 6, 11, 6]  # (s+1)(s+2)(s+3)
    sys = signal.TransferFunction(num, den)

    poles = np.roots(den)
    zeros = np.roots(num)

    print("Analisis Pole-Zero Numerik:")
    print(f"Poles: {poles}")
    print(f"Zeros: {zeros}")
    print(f"System stable: {np.all(np.real(poles) < 0)}")

    # Konstanta waktu untuk pole real
    time_constants = -1 / np.real(poles[np.imag(poles) == 0])
    print(f"Time constants: {time_constants}")

    return sys, poles, zeros

analyze_pole_zero_effects()
numerical_pole_zero_analysis()
```

### Pengaruh Pole-Zero terhadap Respons Sistem

Lokasi pole dan zero dalam bidang-s memiliki pengaruh langsung terhadap karakteristik respons sistem:

#### Pengaruh Pole

| Lokasi Pole             | Karakteristik Respons | Konstanta Waktu |
| ----------------------- | --------------------- | --------------- |
| s = -a (real negatif)   | Eksponensial meluruh  | τ = 1/a         |
| s = -σ ± jωd (kompleks) | Osilasi teredam       | τ = 1/σ         |
| s = ±jω (imajiner)      | Osilasi berkelanjutan | Tak terbatas    |
| s = a (real positif)    | Eksponensial naik     | Tidak stabil    |

#### Pengaruh Zero

Zero mempengaruhi respons dengan cara:

1. Magnitude Response: Zero mengurangi magnitude pada frekuensi tertentu
2. Phase Response: Zero memberikan lead atau lag phase
3. Transient Response: Zero dapat menyebabkan overshoot atau undershoot

<!-- Gambar 6.2: Pengaruh lokasi pole-zero terhadap respons step sistem -->

### Visualisasi Pole-Zero pada Domain s

Representasi visual pole-zero pada bidang kompleks memberikan informasi intuitif tentang karakteristik sistem:

```python
def create_pole_zero_visualization():
    # Membuat grid bidang-s
    real_axis = np.linspace(-3, 1, 400)
    imag_axis = np.linspace(-3, 3, 300)
    s_real, s_imag = np.meshgrid(real_axis, imag_axis)
    s = s_real + 1j  s_imag

    # Definisi fungsi transfer
    # G(s) = (s + 1) / ((s + 0.5)(s + 1 + 2j)(s + 1 - 2j))
    zeros = [-1]
    poles = [-0.5, -1+2j, -1-2j]

    # Hitung magnitude response
    G_magnitude = np.ones_like(s)

    # Kontribusi zeros (numerator)
    for zero in zeros:
        G_magnitude = np.abs(s - zero)

    # Kontribusi poles (denominator)
    for pole in poles:
        G_magnitude /= np.abs(s - pole)

    # Logarithmic scale untuk visualisasi
    G_magnitude_db = 20  np.log10(G_magnitude + 1e-10)

    # Plot 3D surface
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')

    surf = ax.plot_surface(s_real, s_imag, G_magnitude_db,
                          cmap='viridis', alpha=0.7)

    # Mark poles and zeros
    for pole in poles:
        ax.scatter([np.real(pole)], [np.imag(pole)], [0],
                  marker='x', s=200, c='red', label='Pole')

    for zero in zeros:
        ax.scatter([np.real(zero)], [np.imag(zero)], [0],
                  marker='o', s=200, c='blue', label='Zero')

    ax.set_xlabel('Real Part')
    ax.set_ylabel('Imaginary Part')
    ax.set_zlabel('Magnitude (dB)')
    ax.set_title('Pole-Zero Visualization dalam Domain s')

    plt.colorbar(surf)
    plt.show()

    # Plot kontur pada bidang kompleks
    plt.figure(figsize=(10, 8))
    levels = np.linspace(-40, 40, 20)
    contour = plt.contour(s_real, s_imag, G_magnitude_db, levels=levels)
    plt.clabel(contour, inline=True, fontsize=8)

    # Mark poles dan zeros
    for pole in poles:
        plt.plot(np.real(pole), np.imag(pole), 'rx', markersize=15,
                markeredgewidth=3, label='Pole')

    for zero in zeros:
        plt.plot(np.real(zero), np.imag(zero), 'bo', markersize=10,
                markerfacecolor='blue', label='Zero')

    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)

    # Highlight region stabil
    plt.axvspan(-10, 0, alpha=0.2, color='green', label='Stable Region')

    plt.xlabel('Real Part')
    plt.ylabel('Imaginary Part')
    plt.title('Pole-Zero Map dengan Magnitude Contours')
    plt.grid(True)
    plt.legend()
    plt.axis('equal')
    plt.show()

create_pole_zero_visualization()
```

Visualisasi ini menunjukkan bagaimana pole dan zero mempengaruhi magnitude respons di seluruh bidang kompleks. Pole menyebabkan "lembah" (magnitude kecil) sedangkan zero menyebabkan "puncak" (magnitude besar) pada lokasi masing-masing.

## Kriteria Kestabilan Routh-Hurwitz

Kriteria Routh-Hurwitz merupakan metode analisis kestabilan sistem linier yang tidak memerlukan perhitungan pole secara eksplisit. Metode ini dikembangkan oleh Edward John Routh dan Adolf Hurwitz untuk menentukan kestabilan sistem berdasarkan koefisien persamaan karakteristik.

### Dasar Teori Routh-Hurwitz

Untuk sistem dengan persamaan karakteristik:

D(s) = aₙsⁿ + aₙ₋₁sⁿ⁻¹ + ... + a₁s + a₀ = 0

Sistem stabil jika dan hanya jika semua koefisien aᵢ > 0 dan semua elemen kolom pertama tabel Routh-Hurwitz bernilai positif.

#### Syarat Perlu Kestabilan

Sebelum menyusun tabel Routh-Hurwitz, pastikan bahwa:

1. Semua koefisien aᵢ ≠ 0
2. Semua koefisien aᵢ memiliki tanda yang sama (umumnya positif)

Jika syarat ini tidak terpenuhi, sistem pasti tidak stabil.

### Penyusunan Tabel Routh-Hurwitz

Langkah-langkah penyusunan tabel Routh-Hurwitz:

#### Langkah 1: Susunan Baris Awal

Susun koefisien persamaan karakteristik dalam dua baris pertama:

| sⁿ   | aₙ   | aₙ₋₂ | aₙ₋₄ | ... |
| ---- | ---- | ---- | ---- | --- |
| sⁿ⁻¹ | aₙ₋₁ | aₙ₋₃ | aₙ₋₅ | ... |

#### Langkah 2: Perhitungan Baris Selanjutnya

Untuk setiap baris ke-i, hitung elemen menggunakan rumus:

cᵢⱼ = -(aᵢ₊₁,₁ × aᵢ,ⱼ₊₁ - aᵢ,₁ × aᵢ₊₁,ⱼ₊₁) / aᵢ₊₁,₁

```python
import numpy as np
import sympy as sp

def routh_hurwitz_table(coefficients):
    """
    Membuat tabel Routh-Hurwitz dari koefisien persamaan karakteristik

    Parameters:
    coefficients: list - koefisien dari pangkat tertinggi ke terendah

    Returns:
    table: numpy array - tabel Routh-Hurwitz
    stability: bool - status kestabilan sistem
    """

    n = len(coefficients) - 1  # orde sistem

    # Inisialisasi tabel
    cols = (n + 2) // 2
    table = np.zeros((n + 1, cols))

    # Baris pertama (s^n)
    for i in range(cols):
        if 2i < len(coefficients):
            table[0, i] = coefficients[2i]

    # Baris kedua (s^(n-1))
    for i in range(cols):
        if 2i + 1 < len(coefficients):
            table[1, i] = coefficients[2i + 1]

    # Baris-baris selanjutnya
    for i in range(2, n + 1):
        for j in range(cols - 1):
            if table[i-1, 0] == 0:
                # Kasus khusus: elemen pertama kolom = 0
                table[i-1, 0] = 1e-6  # Epsilon kecil

            numerator = (table[i-1, 0]  table[i-2, j+1] -
                        table[i-2, 0]  table[i-1, j+1])
            table[i, j] = -numerator / table[i-1, 0]

    # Cek kestabilan: semua elemen kolom pertama harus positif
    first_column = table[:, 0]
    sign_changes = 0

    for i in range(len(first_column) - 1):
        if first_column[i]  first_column[i+1] < 0:
            sign_changes += 1

    is_stable = (sign_changes == 0) and np.all(first_column > 0)

    return table, is_stable, sign_changes

def print_routh_table(table, coefficients):
    """Mencetak tabel Routh-Hurwitz dalam format yang rapi"""

    n = len(coefficients) - 1
    powers = [f"s^{n-i}" for i in range(n+1)]

    print("Tabel Routh-Hurwitz:")
    print("-"  50)

    # Header
    header = "Power  |"
    for j in range(table.shape[1]):
        header += f"  Col{j+1}  |"
    print(header)
    print("-"  len(header))

    # Baris tabel
    for i in range(table.shape[0]):
        row = f"{powers[i]:6} |"
        for j in range(table.shape[1]):
            if table[i, j] != 0:
                row += f"{table[i, j]:8.3f}|"
            else:
                row += "    0   |"
        print(row)

    print("-"  50)

# Contoh aplikasi
def example_routh_hurwitz():
    # Contoh 1: Sistem stabil
    print("Contoh 1: Sistem Stabil")
    coeffs1 = [1, 6, 11, 6]  # s^3 + 6s^2 + 11s + 6
    table1, stable1, changes1 = routh_hurwitz_table(coeffs1)
    print_routh_table(table1, coeffs1)
    print(f"Sistem stabil: {stable1}")
    print(f"Jumlah pole tidak stabil: {changes1}\n")

    # Contoh 2: Sistem tidak stabil
    print("Contoh 2: Sistem Tidak Stabil")
    coeffs2 = [1, 2, 1, 4]  # s^3 + 2s^2 + s + 4
    table2, stable2, changes2 = routh_hurwitz_table(coeffs2)
    print_routh_table(table2, coeffs2)
    print(f"Sistem stabil: {stable2}")
    print(f"Jumlah pole tidak stabil: {changes2}\n")

    # Contoh 3: Sistem dengan parameter
    print("Contoh 3: Analisis Parametrik")
    print("Persamaan karakteristik: s^3 + 4s^2 + Ks + 2")
    print("Analisis untuk berbagai nilai K:")

    K_values = [1, 2, 5, 8, 10]
    for K in K_values:
        coeffs = [1, 4, K, 2]
        _, stable, changes = routh_hurwitz_table(coeffs)
        print(f"K = {K}: Stabil = {stable}, Pole tidak stabil = {changes}")

example_routh_hurwitz()
```

### Syarat Kestabilan Berdasarkan Routh-Hurwitz

Sistem linier stabil menurut kriteria Routh-Hurwitz jika memenuhi kondisi berikut:

#### Kondisi Kestabilan

1. Kondisi Perlu: Semua koefisien persamaan karakteristik harus ada (tidak nol) dan bertanda sama
2. Kondisi Cukup: Semua elemen kolom pertama tabel Routh-Hurwitz harus positif

#### Interpretasi Hasil

| Kondisi Kolom Pertama | Jumlah Pole Tidak Stabil | Status Sistem |
| --------------------- | ------------------------ | ------------- |
| Semua positif         | 0                        | Stabil        |
| n perubahan tanda     | n                        | Tidak stabil  |
| Ada elemen nol        | Perlu analisis khusus    | Marginal      |

### Kasus Khusus dalam Tabel Routh-Hurwitz

#### Kasus 1: Elemen Pertama Baris = 0

Jika elemen pertama suatu baris sama dengan nol, ganti dengan epsilon kecil (ε) dan lanjutkan perhitungan.

#### Kasus 2: Seluruh Baris = 0

Jika seluruh baris sama dengan nol, sistem memiliki pole simetris terhadap sumbu imajiner. Gunakan turunan baris sebelumnya.

```python
def handle_special_cases():
    """Contoh penanganan kasus khusus dalam tabel Routh-Hurwitz"""

    # Kasus 1: Elemen pertama = 0
    print("Kasus Khusus 1: Elemen Pertama = 0")
    coeffs_case1 = [1, 2, 3, 4]  # Modifikasi untuk demo

    # Kasus 2: Pole pada sumbu imajiner
    print("\nKasus Khusus 2: Pole pada Sumbu Imajiner")
    coeffs_case2 = [1, 0, 4, 0, 4]  # s^4 + 4s^2 + 4 = (s^2 + 2)^2

    # Analisis menggunakan sympy untuk kasus simbolik
    s = sp.Symbol('s')
    poly_case2 = s4 + 4s2 + 4
    roots_case2 = sp.solve(poly_case2, s)

    print(f"Akar persamaan: {roots_case2}")
    print("Pole pada ±j√2 (sumbu imajiner) - sistem marginal stabil")

handle_special_cases()
```

### Contoh Analisis Kestabilan Sistem dengan Routh-Hurwitz

#### Studi Kasus: Sistem Kendali Posisi

Pertimbangkan sistem kendali posisi dengan fungsi transfer loop terbuka:

G(s)H(s) = K / (s(s+2)(s+5))

Persamaan karakteristik sistem loop tertutup:

1 + G(s)H(s) = 0
s³ + 7s² + 10s + K = 0

```python
def position_control_stability_analysis():
    """Analisis kestabilan sistem kendali posisi"""

    print("Analisis Kestabilan Sistem Kendali Posisi")
    print("Persamaan karakteristik: s³ + 7s² + 10s + K = 0")
    print("="  60)

    # Rentang nilai K untuk analisis
    K_range = np.linspace(0.1, 80, 100)
    stable_K = []
    unstable_poles_count = []

    for K in K_range:
        coeffs = [1, 7, 10, K]
        _, is_stable, sign_changes = routh_hurwitz_table(coeffs)

        if is_stable:
            stable_K.append(K)

        unstable_poles_count.append(sign_changes)

    # Tentukan batas kestabilan
    K_critical = 70  # Dari analisis tabel Routh-Hurwitz

    print(f"Analisis Tabel Routh-Hurwitz untuk K = {K_critical}:")
    coeffs_critical = [1, 7, 10, K_critical]
    table_critical, stable_critical, _ = routh_hurwitz_table(coeffs_critical)
    print_routh_table(table_critical, coeffs_critical)

    print(f"\nRentang K untuk kestabilan: 0 < K < {K_critical}")
    print(f"K = {K_critical}: Sistem marginal stabil")
    print(f"K > {K_critical}: Sistem tidak stabil")

    # Plot grafik stabilitas
    plt.figure(figsize=(12, 8))

    # Subplot 1: Rentang stabilitas
    plt.subplot(2, 2, 1)
    stable_region = np.array(unstable_poles_count) == 0
    plt.plot(K_range, stable_region.astype(int), 'b-', linewidth=2)
    plt.axvline(x=K_critical, color='r', linestyle='--', label=f'K_critical = {K_critical}')
    plt.xlabel('Gain K')
    plt.ylabel('Stable (1) / Unstable (0)')
    plt.title('Region Kestabilan')
    plt.grid(True)
    plt.legend()

    # Subplot 2: Jumlah pole tidak stabil
    plt.subplot(2, 2, 2)
    plt.plot(K_range, unstable_poles_count, 'r-', linewidth=2)
    plt.axvline(x=K_critical, color='r', linestyle='--', label=f'K_critical = {K_critical}')
    plt.xlabel('Gain K')
    plt.ylabel('Jumlah Pole Tidak Stabil')
    plt.title('Jumlah Pole Tidak Stabil vs K')
    plt.grid(True)
    plt.legend()

    # Subplot 3: Root locus approximation
    plt.subplot(2, 2, 3)
    K_test = [1, 35, 70, 100]
    for K in K_test:
        coeffs = [1, 7, 10, K]
        roots = np.roots(coeffs)
        plt.scatter(np.real(roots), np.imag(roots),
                   label=f'K={K}', s=100)

    plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
    plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)
    plt.xlabel('Real Part')
    plt.ylabel('Imaginary Part')
    plt.title('Lokasi Pole untuk Berbagai K')
    plt.grid(True)
    plt.legend()

    # Subplot 4: Step response untuk K berbeda
    plt.subplot(2, 2, 4)
    t = np.linspace(0, 3, 1000)

    for K in [10, 35, 65]:  # K dalam rentang stabil
        # Sistem loop tertutup
        num = [K]
        den = [1, 7, 10, K]
        sys = signal.TransferFunction(num, den)
        _, y = signal.step(sys, T=t)
        plt.plot(t, y, label=f'K={K}')

    plt.xlabel('Time (s)')
    plt.ylabel('Step Response')
    plt.title('Respons Step untuk K Berbeda')
    plt.grid(True)
    plt.legend()

    plt.tight_layout()
    plt.show()

position_control_stability_analysis()
```

Analisis ini menunjukkan bagaimana kriteria Routh-Hurwitz dapat digunakan untuk menentukan rentang parameter yang menghasilkan sistem stabil, tanpa perlu menghitung pole secara eksplisit.

## Analisis Kinerja Error Sistem

Analisis error merupakan aspek penting dalam evaluasi kinerja sistem kendali. Error menunjukkan perbedaan antara respons aktual sistem dengan respons yang diinginkan. Pemahaman karakteristik error membantu dalam desain dan optimisasi sistem kendali.

### Definisi dan Jenis Error

Error dalam sistem kendali didefinisikan sebagai:

e(t) = r(t) - y(t)

Di mana:

- e(t) = sinyal error
- r(t) = sinyal referensi (input yang diinginkan)
- y(t) = sinyal output sistem

#### Klasifikasi Error

1. Error Transient: Error yang terjadi selama periode peralihan (transient period)
2. Error Steady-State: Error yang tetap ada setelah sistem mencapai kondisi steady-state
3. Error Dynamic: Error yang bervariasi terhadap waktu

### Error Steady-State (ess)

Error steady-state merupakan karakteristik penting sistem kendali yang menunjukkan akurasi sistem dalam kondisi mapan.

#### Definisi Matematis

Error steady-state didefinisikan sebagai:

ess = lim(t→∞) e(t) = lim(s→0) s·E(s)

Untuk sistem unity feedback:

E(s) = R(s)/(1 + G(s))

#### Konstanta Error Statik

Konstanta error statik digunakan untuk menghitung error steady-state:

1. Konstanta Posisi (Kp):
   Kp = lim(s→0) G(s)

2. Konstanta Kecepatan (Kv):
   Kv = lim(s→0) s·G(s)

3. Konstanta Percepatan (Ka):
   Ka = lim(s→0) s²·G(s)

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import sympy as sp

def calculate_error_constants(num, den):
    """
    Menghitung konstanta error statik (Kp, Kv, Ka)

    Parameters:
    num, den: array - koefisien numerator dan denominator

    Returns:
    Kp, Kv, Ka: konstanta error statik
    """

    # Membuat fungsi transfer
    G = signal.TransferFunction(num, den)

    # Hitung Kp = lim(s->0) G(s)
    Kp = G.dcgain if G.dcgain is not None else 0

    # Hitung Kv = lim(s->0) sG(s)
    # Ini sama dengan G(0) jika ada integrator, 0 jika tidak
    if den[-1] == 0:  # Ada integrator (s di denominator)
        # Hitung orde integrator
        num_zeros_at_origin = 0
        for coeff in reversed(den):
            if coeff == 0:
                num_zeros_at_origin += 1
            else:
                break

        if num_zeros_at_origin >= 1:
            # Ada minimal satu integrator
            new_den = den[:-num_zeros_at_origin]
            if len(new_den) > 0:
                Kv = num[-1] / new_den[-1] if num_zeros_at_origin == 1 else float('inf')
            else:
                Kv = float('inf')
        else:
            Kv = 0
    else:
        Kv = 0

    # Hitung Ka (mirip dengan Kv tetapi untuk s^2)
    if den[-1] == 0 and den[-2] == 0:  # Ada s^2 di denominator
        Ka = float('inf')
    elif den[-1] == 0:  # Ada s di denominator
        # Untuk s^2G(s), perlu dua integrator
        Ka = 0
    else:
        Ka = 0

    return Kp, Kv, Ka

def steady_state_error_analysis():
    """Analisis error steady-state untuk berbagai tipe sistem"""

    print("Analisis Error Steady-State")
    print("="  50)

    # Definisi berbagai tipe sistem
    systems = {
        "Tipe 0": ([1], [1, 2, 1]),           # G(s) = 1/(s^2 + 2s + 1)
        "Tipe 1": ([1], [1, 2, 1, 0]),       # G(s) = 1/(s(s^2 + 2s + 1))
        "Tipe 2": ([1], [1, 2, 1, 0, 0])     # G(s) = 1/(s^2(s^2 + 2s + 1))
    }

    # Input test signals
    inputs = {
        "Step": "1/s",
        "Ramp": "1/s^2",
        "Parabola": "1/s^3"
    }

    # Tabel error steady-state
    error_table = np.zeros((3, 3))  # 3 sistem x 3 input

    for i, (sys_name, (num, den)) in enumerate(systems.items()):
        Kp, Kv, Ka = calculate_error_constants(num, den)

        print(f"\n{sys_name}:")
        print(f"Kp = {Kp:.3f}, Kv = {Kv:.3f}, Ka = {Ka:.3f}")

        # Error untuk step input
        if Kp != 0:
            ess_step = 1 / (1 + Kp)
        else:
            ess_step = float('inf')

        # Error untuk ramp input
        if Kv != 0 and Kv != float('inf'):
            ess_ramp = 1 / Kv
        elif Kv == float('inf'):
            ess_ramp = 0
        else:
            ess_ramp = float('inf')

        # Error untuk parabolic input
        if Ka != 0 and Ka != float('inf'):
            ess_parabola = 1 / Ka
        elif Ka == float('inf'):
            ess_parabola = 0
        else:
            ess_parabola = float('inf')

        error_table[i, :] = [ess_step, ess_ramp, ess_parabola]

        print(f"ess (step) = {ess_step:.3f}")
        print(f"ess (ramp) = {ess_ramp:.3f}")
        print(f"ess (parabola) = {ess_parabola:.3f}")

    return error_table, systems

# Visualisasi error steady-state
def plot_steady_state_errors():
    """Plot respons sistem dan error untuk berbagai input"""

    error_table, systems = steady_state_error_analysis()

    fig, axes = plt.subplots(3, 3, figsize=(15, 12))
    t = np.linspace(0, 20, 1000)

    input_funcs = {
        "Step": lambda t: np.ones_like(t),
        "Ramp": lambda t: t,
        "Parabola": lambda t: 0.5  t2
    }

    for i, (sys_name, (num, den)) in enumerate(systems.items()):
        sys = signal.TransferFunction(num, den)

        for j, (input_name, input_func) in enumerate(input_funcs.items()):
            # Input signal
            u = input_func(t)

            # System response
            _, y, _ = signal.lsim(sys, u, t)

            # Error signal
            error = u - y

            # Plot
            ax = axes[i, j]
            ax.plot(t, u, 'b--', label='Reference', linewidth=2)
            ax.plot(t, y, 'r-', label='Output', linewidth=2)
            ax.plot(t, error, 'g:', label='Error', linewidth=2)

            ax.set_title(f'{sys_name} - {input_name} Input')
            ax.set_xlabel('Time (s)')
            ax.set_ylabel('Amplitude')
            ax.grid(True)
            ax.legend()

            # Tampilkan error steady-state
            ess_value = error_table[i, j]
            if ess_value != float('inf'):
                ax.text(0.7, 0.9, f'ess = {ess_value:.3f}',
                       transform=ax.transAxes, fontsize=10,
                       bbox=dict(boxstyle="round,pad=0.3", facecolor="yellow"))
            else:
                ax.text(0.7, 0.9, 'ess = ∞',
                       transform=ax.transAxes, fontsize=10,
                       bbox=dict(boxstyle="round,pad=0.3", facecolor="red"))

    plt.tight_layout()
    plt.show()

plot_steady_state_errors()
```

### Error Tipe Sistem (Tipe 0, 1, 2, dst)

Klasifikasi sistem berdasarkan jumlah integrator dalam loop terbuka menentukan karakteristik error steady-state:

#### Tipe Sistem dan Karakteristiknya

| Tipe Sistem | Jumlah Integrator | Kp       | Kv       | Ka       | Error Step | Error Ramp |
| ----------- | ----------------- | -------- | -------- | -------- | ---------: | ---------: |
| Tipe 0      | 0                 | Terbatas | 0        | 0        |   1/(1+Kp) |          ∞ |
| Tipe 1      | 1                 | ∞        | Terbatas | 0        |          0 |       1/Kv |
| Tipe 2      | 2                 | ∞        | ∞        | Terbatas |          0 |          0 |

#### Implikasi Praktis

1. Sistem Tipe 0: Tidak dapat mengikuti input ramp tanpa error
2. Sistem Tipe 1: Dapat mengikuti input step dan ramp dengan error terbatas
3. Sistem Tipe 2: Dapat mengikuti input step, ramp, dan parabola

<!-- Gambar 6.3: Perbandingan respons sistem tipe 0, 1, dan 2 terhadap berbagai input -->

### Perhitungan Error Integral

Kriteria integral error digunakan untuk evaluasi kinerja sistem secara kuantitatif. Kriteria ini mengintegrasikan error selama periode waktu tertentu.

#### Integral of Absolute Error (IAE)

IAE = ∫₀^∞ |e(t)| dt

IAE memberikan bobot yang sama untuk semua error tanpa mempertimbangkan waktu terjadinya.

```python
def calculate_iae(t, error):
    """Menghitung Integral of Absolute Error"""
    return np.trapz(np.abs(error), t)

# Contoh perhitungan IAE
def iae_example():
    """Contoh perhitungan IAE untuk sistem berbeda"""

    # Definisi sistem
    systems = {
        "Underdamped": ([1], [1, 0.4, 1]),
        "Critically damped": ([1], [1, 2, 1]),
        "Overdamped": ([1], [1, 3, 1])
    }

    t = np.linspace(0, 10, 1000)

    fig, axes = plt.subplots(2, 2, figsize=(12, 10))

    iae_values = {}

    for i, (name, (num, den)) in enumerate(systems.items()):
        sys = signal.TransferFunction(num, den)

        # Step response
        _, y = signal.step(sys, T=t)

        # Error calculation (assuming unit step input)
        error = 1 - y

        # Calculate IAE
        iae = calculate_iae(t, error)
        iae_values[name] = iae

        # Plot response
        ax = axes[i//2, i%2]
        ax.plot(t, y, 'b-', label='Output', linewidth=2)
        ax.plot(t, np.ones_like(t), 'r--', label='Reference', linewidth=2)
        ax.plot(t, error, 'g:', label='Error', linewidth=2)

        ax.set_title(f'{name} (IAE = {iae:.3f})')
        ax.set_xlabel('Time (s)')
        ax.set_ylabel('Amplitude')
        ax.grid(True)
        ax.legend()

    # Bar chart perbandingan IAE
    ax = axes[1, 1]
    names = list(iae_values.keys())
    values = list(iae_values.values())

    bars = ax.bar(names, values, color=['blue', 'green', 'red'], alpha=0.7)
    ax.set_title('Perbandingan IAE')
    ax.set_ylabel('IAE Value')

    # Tambahkan nilai di atas bar
    for bar, value in zip(bars, values):
        ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01,
                f'{value:.3f}', ha='center', va='bottom')

    plt.tight_layout()
    plt.show()

    return iae_values

iae_results = iae_example()
```

#### Integral of Squared Error (ISE)

ISE = ∫₀^∞ e²(t) dt

ISE memberikan penalti lebih besar untuk error yang besar karena menggunakan kuadrat error.

```python
def calculate_ise(t, error):
    """Menghitung Integral of Squared Error"""
    return np.trapz(error2, t)
```

#### Integral of Time-weighted Absolute Error (ITAE)

ITAE = ∫₀^∞ t|e(t)| dt

ITAE memberikan penalti lebih besar untuk error yang terjadi pada waktu yang lebih lama.

```python
def calculate_itae(t, error):
    """Menghitung Integral of Time-weighted Absolute Error"""
    return np.trapz(t  np.abs(error), t)
```

#### Integral of Time-weighted Squared Error (ITSE)

ITSE = ∫₀^∞ t·e²(t) dt

ITSE mengombinasikan time-weighting dengan squared error.

```python
def calculate_itse(t, error):
    """Menghitung Integral of Time-weighted Squared Error"""
    return np.trapz(t  error2, t)

def comprehensive_error_analysis():
    """Analisis komprehensif semua kriteria integral error"""

    # Sistem test dengan parameter berbeda
    zeta_values = [0.3, 0.7, 1.0, 1.5]  # Damping ratios
    wn = 1  # Natural frequency

    t = np.linspace(0, 15, 1000)

    results = {
        'Zeta': [],
        'IAE': [],
        'ISE': [],
        'ITAE': [],
        'ITSE': []
    }

    plt.figure(figsize=(15, 10))

    for i, zeta in enumerate(zeta_values):
        # Second-order system: G(s) = wn^2 / (s^2 + 2zetawns + wn^2)
        num = [wn2]
        den = [1, 2zetawn, wn2]
        sys = signal.TransferFunction(num, den)

        # Step response
        _, y = signal.step(sys, T=t)
        error = 1 - y  # Error for unit step

        # Calculate all error criteria
        iae = calculate_iae(t, error)
        ise = calculate_ise(t, error)
        itae = calculate_itae(t, error)
        itse = calculate_itse(t, error)

        # Store results
        results['Zeta'].append(zeta)
        results['IAE'].append(iae)
        results['ISE'].append(ise)
        results['ITAE'].append(itae)
        results['ITSE'].append(itse)

        # Plot step response
        plt.subplot(2, 3, i+1)
        plt.plot(t, y, 'b-', linewidth=2, label='Output')
        plt.plot(t, np.ones_like(t), 'r--', linewidth=2, label='Reference')
        plt.plot(t, error, 'g:', linewidth=2, label='Error')
        plt.title(f'ζ = {zeta}')
        plt.xlabel('Time (s)')
        plt.ylabel('Amplitude')
        plt.grid(True)
        plt.legend()

    # Plot perbandingan kriteria error
    plt.subplot(2, 3, 5)
    x = np.arange(len(zeta_values))
    width = 0.2

    plt.bar(x - 1.5width, results['IAE'], width, label='IAE', alpha=0.8)
    plt.bar(x - 0.5width, results['ISE'], width, label='ISE', alpha=0.8)
    plt.bar(x + 0.5width, results['ITAE'], width, label='ITAE', alpha=0.8)
    plt.bar(x + 1.5width, results['ITSE'], width, label='ITSE', alpha=0.8)

    plt.xlabel('Damping Ratio')
    plt.ylabel('Error Value')
    plt.title('Perbandingan Kriteria Integral Error')
    plt.xticks(x, [f'{z}' for z in zeta_values])
    plt.legend()
    plt.grid(True)

    # Tabel hasil
    plt.subplot(2, 3, 6)
    plt.axis('tight')
    plt.axis('off')

    table_data = []
    for i in range(len(zeta_values)):
        row = [f'{results["Zeta"][i]:.1f}',
               f'{results["IAE"][i]:.3f}',
               f'{results["ISE"][i]:.3f}',
               f'{results["ITAE"][i]:.3f}',
               f'{results["ITSE"][i]:.3f}']
        table_data.append(row)

    table = plt.table(cellText=table_data,
                     colLabels=['ζ', 'IAE', 'ISE', 'ITAE', 'ITSE'],
                     cellLoc='center',
                     loc='center')
    table.auto_set_font_size(False)
    table.set_fontsize(10)
    table.scale(1.2, 1.5)
    plt.title('Tabel Nilai Kriteria Error')

    plt.tight_layout()
    plt.show()

    return results

error_results = comprehensive_error_analysis()
```

### Ringkasan dan Aplikasi Praktis

Analisis kestabilan dan error sistem memberikan fondasi untuk:

1. Desain Kontroler: Menentukan parameter kontroler yang menghasilkan sistem stabil
2. Optimisasi Kinerja: Memilih kriteria error yang sesuai dengan aplikasi
3. Analisis Robustness: Mengevaluasi toleransi sistem terhadap gangguan

#### Panduan Pemilihan Kriteria Error

| Kriteria | Karakteristik        | Aplikasi Terbaik           |
| -------- | -------------------- | -------------------------- |
| IAE      | Penalti merata       | Sistem dengan noise rendah |
| ISE      | Penalti error besar  | Sistem presisi tinggi      |
| ITAE     | Penalti error lambat | Sistem real-time           |
| ITSE     | Kombinasi lengkap    | Optimisasi komprehensif    |

<!-- Gambar 6.4: Flowchart pemilihan metode analisis kestabilan dan kriteria error -->

Pemahaman komprehensif tentang analisis kestabilan dan error sistem memungkinkan insinyur untuk merancang sistem kendali yang tidak hanya stabil tetapi juga memenuhi spesifikasi kinerja yang diinginkan.

